### 变量声明和定义区别？

- 声明仅仅是把变量的声明的**位置及类型**提供给编译器，并**不分配内存空间**；定义要在定义的地方为其分配存储空间。
- 相同变量可以在**多处声明**（外部变量extern），但只能在**一处定义**。

### "零值比较"？

- bool类型：if(flag)
- int类型：if(flag == 0)
- 指针类型：if(flag == nullptr)
- float类型：if((flag >= -0.000001) && (flag <= 0. 000001))

### strlen和sizeof区别？

- sizeof是**运算符**，并不是函数，结果在**编译时**得到而非运行中获得；strlen是字符处理的**库函数**。
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的**C风格字符串**。
- 因为sizeof值在编译时确定，所以不能用来得到**动态分配**（运行时分配）存储空间的大小。

### 同一对象可以互相赋值吗？

- 可以，但含有指针成员时需要注意。
- 对比类的对象赋值时深拷贝和浅拷贝。
- 自我赋值，使用copy-and-swap避免自我检测

```cc
Widget& Widget::operator=(const Widget& rhs)
{
    Widget temp(rhs);
    swap(temp);
    return *this;
}
// 或者不要拷贝函数参数。你应该按值传递参数，让编译器来完成拷贝工作。
Widget& Widget::operator=(const Widget rhs)
{
    swap(*this, rhs);
    return *this;
}
```

### 结构体内存对齐问题？

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同（若无虚函数）。
- 未特殊说明（#pragma）时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）。

### static作用是什么？在C和C++中有何区别？

- static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。
  - 对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；
  - 对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；
  - 修饰函数时作用和修饰全局变量相同，都是为了限定访问域。
- C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。
- static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。
- 未初始化时，static变量默认值为0。

### 结构体和类的区别？

- 结构体的默认限定符是public；类是private。

### malloc和new的区别？

- malloc和free是标准**库函数**，支持覆盖；new和delete是**运算符**，并且支持重载。
- malloc仅仅分配内存空间，free仅仅回收空间，**不具备调用构造函数和析构函数功能**，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。
- malloc和free返回的是**void类型指针**（必须进行类型转换），new和delete返回的是**具体类型指针**。

### 指针和引用区别？

- 引用只是别名，**不占用具体存储空间**，只有声明没有定义；指针是具体变量，需要占用存储空间。

- 引用在声明时**必须初始化**为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就**不可以再改变**（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- **不存在指向空值的引用**，必须有具体实体；但是存在指向空值的指针。

### 宏定义和函数有何区别？

- 宏在**预编译时完成替换**，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 宏函数属于在结构中插入代码，**没有返回值**；函数调用具有返回值。
- 宏函数参数**没有类型**，不进行类型检查；函数参数具有类型，需要检查类型。
- 宏函数不要在最后加分号。

### 宏定义常量和const常量区别？

- 宏替换发生在**编译阶段之前**，属于文本插入替换；const作用发生于编译过程中。
- 宏**不检查类型**；const会检查数据类型。
- 宏定义的数据**没有分配内存空间**，只是插入替换掉，存储于程序的代码段中；const定义的变量只是值不能改变，但要分配内存空间，存储于程序的数据段中。
- **定义域不同**，宏定义是全局的，而const常量是局部的
- **是否可以做函数参数**，宏定义不能作为参数传递给函数，const常量可以在函数的参数列表中出现
- **是否可以调试**，const 常量可以进行调试，#define 是不能进行调试的，因为在预编译阶段就已经替换掉了
- **是否可以再定义**，const 不足的地方，是不能重定义，而 #define 可以通过 #undef 取消某个符号的定义，再重新定义。

### 宏定义和typedef区别？

- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。

- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。

- 宏不检查类型；typedef会检查数据类型。

- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。

- 注意对指针的操作，

  ```cc
  typedef char *pStr1;
  #define pStr2 char *;
  pStr1 s1, s2;
  pStr2 s3, s4;
  //其中s1, s2, s3是char*类型，而s4是char类型。
  ```

### 宏定义和内联函数(inline)区别？

- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
- 内联函数本身是函数，强调函数特性，具有重载等功能。
- 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。

### 条件编译#ifdef, #else, #endif作用？

- 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。
- 用于子程序前加#define DEBUG用于程序调试。
- 应对硬件的设置（机器类型等）。
- 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。

### volatile有什么作用？

- volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
- 多线程中被几个任务共享的变量需要定义为volatile类型。

### 什么是常引用const int &？

- 常引用可以理解为常量指针。
- 常引用下，原变量值不会被别名所修改。
- 原变量的值可以通过原名修改。
- 常引用通常用作只读变量别名或是形参传递。

### 区别以下指针类型？

```
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

数组和函数本质上是一样的。只是一个是()一个是[]。优先级都比*高。数组和函数应该统一思考。数组是展开的函数，函数是压缩的数组。数组是空间。函数是时间。

### 对于数组int a[10]来说，a和&a有什么区别？

- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
- &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。

### 数组名和指针（这里为指向数组首元素的指针）区别？

- 二者均可通过**增减偏移量**来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以**数组名没有自增、自减等操作**。
- 当**数组名当做形参**传递给调用函数后，就失去了原有特性，**退化成一般指针**，多了自增、自减操作，但**sizeof**运算符不能再得到原数组的大小了。

### 野指针是什么？

- 也叫空悬指针，不是指向null的指针（空指针），是指向垃圾内存的指针。

- 产生原因及解决办法：
  - 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
  - 指针free或delete之后没有及时置空 => 释放操作后立即置空。

### 为什么用nullptr而不用NULL？

- C语言中#define NULL ((void \*)0)，NULL实际上是一个空指针。C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针

- C++是强类型语言，void\*是不能隐式转换成其他类型的指针的。

  ```cc
  #ifdef __cplusplus
  #define NULL 0
  #else
  #define NULL ((void *)0)
  #endif
  ```

  C++中，NULL实际上是0。这时候用0表示空指针。但是实际上，用NULL代替0表示空指针在函数重载时会出现问题，程序执行的结果会与我们的想法不同，它会选择int形参，而不是void*形参版本。

- 因此在C++11版本(2011年发布)中特意引入了nullptr这一新的关键字来代指空指针。

### 内存管理中的堆和栈的区别？

- 申请方式不同。
  - 栈由系统自动分配。
  - 堆由程序员手动分配。
- 申请大小限制不同。
  - 栈顶和栈底是之前预设好的，向低地址扩展，总的大小固定，可以通过ulimit -a查看，由ulimit -s修改。
  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
- 申请效率不同。
  - 栈由系统分配，速度快，不会有碎片。
  - 堆由程序员分配，速度慢，且会有碎片。

### delete和delete[]区别？

- delete只会调用一次析构函数。
- delete[]会调用数组中每个元素的析构函数。