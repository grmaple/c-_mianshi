# static

### static关键字的作用

全局变量、静态局部变量、静态全局变量都在静态存储区分配空间，而局部变量在栈分配空间。

把局部变量改变为静态变量后是改变了他的存储方式，即改变了他的生存期。

把全局变量改变为静态变量后是改变了他的作用域，限制了他的使用范围。

因此static这个说明符在不同的地方起的作用是不同的。

##### 1.全局静态变量

在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.

未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

**全局静态变量和非静态全局变量的区别**：作用域

非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。

而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

##### 2.局部静态变量

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

**局部静态变量和非静态局部变量的区别**

局部静态变量会被放在程序的静态数据存储区里，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是他与堆栈变量和堆变量的区别。

局部变量在栈分配空间

##### 3.静态函数

在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是**extern**的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

**头文件中声明非static的全局函数，代表多个cpp可以用**

**cpp内声明static的全局函数，代表只是本cpp可以用**

##### 4类的静态成员

在类中，静态成员可以实现多个对象之间的**数据共享**，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

##### 5.类的静态函数

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

**类的静态函数和类的普通成员函数的区别**

普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。

但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。如果静态成员函数中要引用非静态成员时，可通过对象来引用。

### 外部链接性,内部链接性和无链接性

使用static关键字可以使得原先拥有external属性的标识符变成internal属性

- 使用static关键字修改链接属性，只对具有文件作用域的标识符生效(可以保护标识符)
- 链接属性只能修改一次

首先从静态变量说起. C++里面静态变量有三种: 分别是外部链接性,内部链接性和无链接性.
声明外部链接的变量的方法是在代码块外面声明它. 此变量是**全局变量**,多文件中亦可用.另一个文件如果需要引用其它文件中的全局变量.需在代码块外加extern 声明.
声明内部链接的变量的方法是在代码块外面声明它并加上static限定符. 此变量是**静态全局变量**,但仅在本文件中可用.
声明无链接的变量的方法是在代码块里面声明它并加上static限定符. 此变量是**静态局部变量**,但仅在本代码块中可用.

全局变量因为容易被改变而产生一些不必要的麻烦所以一般不推荐使用. 一般用全局变是为了共享一个数据,而不能随便改动.这样可以在定义变量时加const限定符.
定义静态变量时如果没有初始化编译器会自动初始化为0.

最后在说一下无链接性静态变量.
对于auto型变量, 函数在每次调用时产生一个随机位置与随机值.
而对于static型变量第一次被初始化后以后其位置叫不会变了.见上面输出的地址.因为地址不变其内的值也自然是以前的值了.可以用来做值的传递

### static关键字

1.加了static关键字的全局变量只能在本文件中使用。例如在a.c中定义了static int a=10;那么在b.c中用extern int a是拿不到a的值得，a的作用域只在a.c中。 2.static定义的静态局部变量分配在数据段上，普通的局部变量分配在栈上，会因为函数栈帧的释放而被释放掉。
2.对一个类中成员变量和成员函数来说，加了static关键字，则此变量/函数就没有了this指针了，必须通过类名才能访问

### 静态变量什么时候初始化

静态变量存储在虚拟地址空间的数据段和bss段，

C语言中其在代码执行之前初始化，属于编译期初始化。

而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造



**static作用：“改变生命周期” 或者 “改变作用域”**

程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）中。

**1.作用于变量：**

用static声明局部变量——延长生命周期

局部变量指在代码块{}内部定义的变量，只在代码块内部有效（作用域），用static声明局部变量时，则改变变量的存储方式（生命期），使变量成为静态的局部变量，即编译时就为变量分配内存，直到程序退出才释放存储单元。这样，使得该局部变量有记忆功能，可以记忆上次的数据，不过由于仍是局部变量，因而只能在代码块内部使用（作用域不变）。

用static声明外部变量——限制作用域

外部变量指在所有代码块{}之外定义的变量，它缺省为静态变量，编译时分配内存，程序结束时释放内存单元。同时其作用域很广，整个文件都有效甚至别的文件也能引用它。为了限制某些外部变量的作用域，使其**只在本文件中有效**，而不能被其他文件引用，可以用static关键字对其作出声明。

**总结：**用static声明局部变量，使其变为静态存储方式(静态数据区)，作用域不变；用static声明外部变量，其本身就是静态变量，这只会改变其连接方式，使其只在本文件内部有效，而其他文件不可连接或引用该变量。

**2.作用于函数：**

使用static用于函数定义时，对函数的连接方式产生影响，使得函数只在**本文件内部有效**，对其他文件是不可见的。这样的函数又叫作静态函数。使用静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制。

如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用。另外在要引用别的文件中定义的外部函数的文件中，使用extern声明要用的外部函数即可。