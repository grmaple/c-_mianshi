## new/delete

### new

##### 1．new() 

分配这种类型的一个大小的内存空间,并以括号中的值来初始化这个变量;

##### 2．new[] 

分配这种类型的n个大小的内存空间,并用默认构造函数来初始化这些变量;

char* p=new char[6];

//p="Hello";不能将字符串直接赋值，指针p指向的是字符串的第一个字符

strcpy(p,"Hello");

##### 3．开辟单变量地址空间

1)new int; //开辟一个存放数组的存储空间,返回一个指向该存储空间的地址.int *a = new int 即为将一个int类型的地址赋值给整型指针a.

2)int *a = new int(5) 作用同上,但是同时将整数赋值为5

##### 4．开辟数组空间

一维: int *a = new int[100];开辟一个大小为100的整型数组空间

二维: int **a = new int\[5][6]

三维及其以上:依此类推.

一般用法: new 类型 [初值]

##### 6．new运算符

最常用的是作为运算符的new，比如：

string *str = new string(“test new”);

作为运算符，new和sizeof一样，是C 内置的，你不能对它做任何的改变，除了使用它。

new会在堆上分配一块内存，并会自动调用类的构造函数。

### delete

##### 1.回收new分配的单个对象的内存空间的时候用delete，

int *a = new int;

delete a; //释放单个int的空间

##### 2.回收new[ ]分配的一组对象的内存空间的时候用 delete[ ];

int *a = new int[5];

delete [] a; //释放int数组空间



基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；

但是对于类对象数组，只能用 delete[]。

对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间。

 **所以一个简单的使用原则就是：new 和 delete、new[] 和 delete[] 对应使用。**

### new/delete与malloc/free的区别

new/delete是C++的关键字，

而malloc/free是C语言的库函数，

后者使用必须指明申请内存空间的大小，

对于类类型的对象，后者不会调用构造函数和析构函数

### malloc与new区别

malloc需要给定申请内存的大小，返回的指针为 void *指针，需要强转。
new会调用构造函数，不用指定内存大小，返回的指针不用强转。

1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；

2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。

3、new不仅分配一段内存，而且会调用构造函数，malloc不会。

4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。

5、new是一个操作符可以重载，malloc是一个库函数。

6、malloc分配的内存不够的时候，可以用realloc扩容。new没有这样操作。

7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。

8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。

### new/delete原理

new会先申请空间,再调用构造函数,delete会先调用析构函数,再释放空间。

new和delete是用户进行动态内存申请和释放的操作符,operator new 和operator delete是系统提供的全局函数。

new在底层调用operator new函数申请空间,delete在底层通过operator delete函数释放空间。

operator new和operator delete底层调用了malloc和free



### malloc()

https://blog.csdn.net/yusiguyuan/article/details/39496057

Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。

Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。

brk分配的内存需要等到高地址内存释放以后才能释放（可以free，但是内存实际上没有释放，这就是内存碎片产生的原因），而mmap分配的内存可以单独释放。

默认情况下： 当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。这时才是真的释放了内存。

##### **内存分配的原理**

从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：**brk和mmap（不考虑共享内存）。**

1、brk是将数据段(.data)的最高地址指针_edata往高地址推；

2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。

   这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生**缺页中断**，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。

当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：

　　1.检查要访问的虚拟地址是否合法

　　2.查找/分配一个物理页

　　3.填充物理页内容(读取磁盘，或者直接置0，或者啥也不干)

　　4.建立映射关系(虚拟地址到物理地址)

　　5.重新执行发生缺页中断的那条指令

　　如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。（ majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。）

可以用命令ps -o majflt minflt -C program来查看进程的majflt, minflt的值

##### malloc/calloc/realloc的区别:

```cpp
//申请大小为size的内存块
void* malloc (size_t size);

//申请大小为num*size的内存块,并将每个元素初始化为0
void* calloc (size_t num, size_t size);

//ptr为NULL,申请空间类似于malloc
//ptr不为NULL,则将ptr指向空间改变大小为size,并且如果改变的空间远大于旧空间,会申请新内存块,并将原数据拷贝过来,释放旧空间,返回新地址
void* realloc (void* ptr, size_t size);
```

### **free()**

操作系统在调用malloc函数时，会默认在malloc分配的物理内存前面分配一个数据结构，这个数据结构记录了这次分配内存的大小，在用户眼中这个操作是透明的。

那么当用户需要free时，free函数会把指针退回到这个结构体中，找到该内存的大小，这样就可以正确的释放内存了。

1）free只是释放了malloc所申请的内存，并没有改变指针的值；

2）由于指针所指向的内存空间已经被释放，所以其他代码有机会改写其中的内容，相当于该指针从此指向了自己无法控制的区域（无法控制这么说还是可以去使用的，只是危险），也成为野指针（野指针指指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为NULL避免）。

3）为了避免错误，所以最好在free之后，使指针指向NULL。

根据原理的解释分析：free函数的作用只是告诉操作系统该内存不用了，可以收回，操作系统就把该内存链接到链接表上，

但是这段内存用户还是可以访问到的，只是该内存的值可能已经发生了变化。

free函数只是将参数指针指向的内存归还给操作系统，并不会把参数指针置NULL，为了以后访问到被操作系统重新分配后的错误数据，所以在调用free之后，通常需要手动将指针置NULL。从另一个角度来看，内存这种底层资源都是由操作系统来管理的，而不是编译器，编译器只是向操作系统提出申请。所以free函数是没有能力去真正的free内存的。只是告诉操作系统它归还了内存，然后操作系统就可以修改内存分配表，以供下次分配。

### 内存泄漏

内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
内存泄漏的分类：

1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

### 如何判断内存泄漏

内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。

### 如何处理内存泄漏？

使用Valgrind，mtrace检测

mtrace是一个C函数，在<mcheck.h>里声明及定义，函数原型为：void mtrace(void);

mtrace的原理是记录每一对malloc-free的执行，若每一个malloc都有相应的free，则代表没有内存泄露，对于任何非malloc/free情況下所发生的内存泄露问题，mtrace并不能找出来。

Valgrind 是一款 Linux下（支持 x86、x86_64和ppc32）程序的内存调试工具，它可以对编译后的二进制程序进行内存使用监测（C语言中的malloc和free，以及C++中的new和delete），找出内存泄漏问题。

## new与malloc的区别，delete和free的区别？

free和malloc匹配：释放malloc出来动态内存;

delete和new匹配：释放new出来的动态内存空间。

1.new和delete是关键字，需要编译器的支持；malloc和free是库函数，需要包含库头文件。

2.malloc/free是c/c++标准库的函数，new/delete除了分配空间还会调用构造函数和析构函数进行初始化和清理（清理成员）。

3.malloc/free需要手动计算类型大小且返回值是void*，new/delete可以自己计算类型大小，返回对应的指针。

4.对于自定义类型new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。（对malloc和free进行了封装）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

5.在类和对象的时候会有很大区别。在使用malloc和free来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用new和delete就可以既释放对象的内存的同时，调用这个对象的析构函数。

**如果问到malloc，还有可能问你memcpy等realloc函数能不能在C++中使用，绝对不能，因为这些函数进行的都是内存值拷贝（也就是对象的浅拷贝），会发生浅拷贝这个严重的问题！**

### 内存溢出和内存泄漏的区别

内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

memory leak会最终会导致out of memory！

内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 

内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。

一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. 

   以发生的方式来分类，内存泄漏可以分为4类： 

1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 
2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 
3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 
4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 

从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到