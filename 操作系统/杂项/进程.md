## 进程

### 进程、进程组和会话

进程是操作系统的一个核心概念。每个进程都有自己唯一的标识：进程ID，也有自己的生命周期。一个典型的进程的生命周期如图4-1所示。

![img](https://i.loli.net/2020/10/26/EWmSDNak1dzPL9J.png)

**进程都有父进程，父进程也有父进程，这就形成了一个以init进程为根的家族树。**除此以外，进程还有其他层次关系：进程、进程组和会话。

进程组和会话在进程之间形成了两级的层次：进程组是一组相关进程的集合，会话是一组相关进程组的集合。

这样说来，一个进程会有如下ID：

·PID：进程的唯一标识。对于多线程的进程而言，所有线程调用getpid函数会返回相同的值。

·PGID：进程组ID。每个进程都会有进程组ID，表示该进程所属的进程组。默认情况下新创建的进程会继承父进程的进程组ID。

·SID：会话ID。每个进程也都有会话ID。默认情况下，新创建的进程会继承父进程的会话ID。

前面提到过，新进程默认继承父进程的进程组ID和会话ID，如果都是默认情况的话，那么追根溯源可知，所有的进程应该有共同的进程组ID和会话ID。但是调用ps axjf可以看到，实际情况并非如此，系统中存在很多不同的会话，每个会话下也有不同的进程组。

为何会如此呢？

就像家族企业一样，如果从创业之初，所有家族成员都墨守成规，循规蹈矩，默认情况下，就只会有一个公司、一个部门。但是也有些“叛逆”的子弟，愿意为家族公司开疆拓土，愿意成立新的部门。这些新的部门就是新创建的进程组。如果有子弟“离经叛道”，甚至不愿意呆在家族公司里，他别开天地，另创了一个公司，那这个新公司就是新创建的会话组。由此可见，系统必须要有改变和设置进程组ID和会话ID的函数接口，否则，系统中只会存在一个会话、一个进程组。

**进程组和会话是为了支持shell作业控制而引入的概念。**

当有新的用户登录Linux时，登录进程会为这个用户创建一个会话。用户的登录shell就是会话的首进程。会话的首进程ID会作为整个会话的ID。**会话是一个或多个进程组的集合，囊括了登录用户的所有活动。**在登录shell时，用户可能会使用管道，让多个进程互相配合完成一项工作，这一组进程属于同一个进程组。

当用户通过SSH客户端工具（putty、xshell等）连入Linux时，与上述登录的情景是类似的。

通常，会话开始于用户登录，终止于用户退出，期间的所有进程都属于这个会话。**一个会话一般包含一个会话首进程、一个前台进程组和一个后台进程组，控制终端可有可无；**此外，前台进程组只有一个，后台进程组可以有多个，这些进程组共享一个控制终端。

- 前台进程组：
  该进程组中的进程可以向终端设备进行读、写操作（属于该组的进程可以从终端获得输入）。该进程组的 ID 等于控制终端进程组 ID，通常据此来判断前台进程组。
- 后台进程组：
  会话中除了会话首进程和前台进程组以外的所有进程，都属于后台进程组。该进程组中的进程只能向终端设备进行写操作。

下图为会话、进程组、进程和控制终端之间的关系（登录 shell 进程本身属于一个单独的进程组）。

![Linux 守护进程的实现](https://i.loli.net/2020/10/26/Eu61de7nFMzxQhA.png)

如果调用进程非组长进程，那么就能创建一个新会话：

- 该进程变成新会话的首进程
- 该进程成为一个新进程组的组长进程
- 该进程没有控制终端，如果之前有，则会被中断（会话过程对控制终端的独占性）

也就是说：组长进程不能成为新会话首进程，新会话首进程必定成为组长进程。

### **守护、僵尸、孤儿进程概念**

**孤儿进程：**

孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程。

由init进程收养系统的孤儿进程。

**作用：**
在现实中用户可能刻意使进程成为孤儿进程，这样就可以让它与父进程会话脱钩，成为后面会介绍的守护进程。

**僵尸进程：**

什么是僵尸进程？

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程

**守护进程概念：**

我们可以认为守护进程就是后台服务进程，因为它会有一个很长的生命周期提供服务，关闭终端不会影响服务，也就是说可以忽略某些信号。

**下面介绍一下创建守护进程的步骤**

1、fork()创建子进程，父进程exit()退出；

​	//在形式上做到了与控制终端的脱离，在后台工作

2、在子进程调用setsid()创建新会话；

​	//使进程完全独立出来

3、再次 fork() 一个子进程，父进程exit退出；

​	//使进程不再是会话首进程来禁止进程重新打开控制终端。

4、在子进程中调用chdir()让根目录“/”成为子进程的工作目录；

​	//避免原父进程当前目录带来的一些麻烦

5、在子进程中调用umask()重设文件权限掩码为0；

​	//相当于把权限开发

6、在子进程中close()不需要的文件描述符；

​	//关闭失去价值的输入、输出、报错等对应的文件描述符

7、守护进程退出处理。

​	//实现 kill 发出的signal信号处理，达到进程的正常退出。

![img](https://i.loli.net/2020/10/26/xHIbQCSLzFTKMZ3.jpg)