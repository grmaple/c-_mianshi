## 如何设计好的散列函数

一个好的散列函数应该满足简单均匀散列

1、直接定址法

关键码本身和地址之间存在某个线性函数关系时，散列函数取为关键码的线性函数，即：H(key)=a*key+b，a、b均为常数。

这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合査找表较小且连续的情况。由于这样的限制，在现实应用中，直接定址法虽然简单，但却并不常用。

2、数字分析法

假设关键码完全已知，且每个关键码都是以某个数r为基数（例以10为基数的十进制数）的值，则关键码中若干位恰能构成分布比较均匀的散列地址空间时，可取关键码的若干位的组合作为散列地址。

3、平方取中法

将关键码key平方，取key ^2中间几位作为其散列地址f(key)的值。

假如有以下关键字序列{421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取{72，89，00}作为Hash地址。

适合于不知道关键字分布，而位数不是很大的情况

4、折叠法

折叠法是将关键字从左到右分割成位数相等的几部分（注意组后一部分位数不够的可以短些）

适用于事先不知道关键字分布，关键字位数较多的情况

5、除留余数法（最常用）

通过选择适当的正整数p，按计算公式f(key)=key%p来计算关键码key的散列地址。

若关键码个数为n，散列表表长为m（一般m>=n），通常选p为小于或等于表长m的最大素数或不包含小于20的质因子的合数，一般也要求p>=n。

这种方法计算最简单，也不需根据全部关键码的分布情况研究如何从中析取数据，最常用。

6、随机数法

选择一个随机数，取关键字的随机函数值为它的散列地址。也就是f(key)=random(key)。这里random是随机函数。当关键字长度不等时，采用这个方法构造散列函数比较合适。

## 四、哈希表解决冲突的方法及优缺点

1、开放定址法

开放定址指散列表的地址对任何记录数据都是开放的，即可存储使用。但散列表长度一旦确定，总的可用地址是有限的。闭散列表表长不小于所需存储的记录数，发生冲突总能找到空的散列地址将其存入。查找时，按照一种固定的顺序检索散列表中的相应项，直到找到一个关键字等于k或找到一个空单元将k插入，故是动态查找结构。

1）线性探测法

从发生冲突位置的下一个位置开始寻找空的散列地址。发生冲突时，线性探测下一个散列地址是：Hi=(H(key)+di)%m，（di=1,2,3...,m-1）。闭散列表长度为m。它实际是按照H(key)+1，H(key)+2,...,m-1,0,1,H(key)-1的顺序探测，一旦探测到空的散列地址，就将关键码记录存入。

该方法会产生堆积现象，即使是同义词也可能会争夺同一个地址空间，今后在其上的查找效率会降低。

2）二次探测法

发生冲突时，下一位置的探测采用公式：Hi=(H(key)+di)%m，(di=1^2,-1^2,2^2,-2^2,.....,q^2,-q^2,q<=根号下m)

在一定程度上可解决线性探测中的堆积现象。

3）随机探测法

di为{1,2,3,...,m-1}中的数构成的一个随机数列中顺序取的一个数

4）再散列函数法

除基本散列函数外，事先设计一个散列函数序列，RH1,RH2,...,RHk，k为某个正整数。RHi均为不同的散列函数。对任一关键码，若在某一散列函数上发生冲突，则再用下一个散列函数，直到不发生冲突为止。

5）建立公共溢出区（单链表或顺序表实现）

另外开辟一个存储空间，当发生冲突时，把同义词均顺序放入该空间。若把散列表看成主表或父表，则公共的同义词表就是一个次表或子表。查找时，现在散列表中查，找不到时再去公共同义词子表顺序查找。

2、链地址法

将所有散列地址相同的记录存储在同一个单链表中，该单链表为同义词单链表，或同义词子表。该单链表头指针存储在散列表中。散列表就是个指针数组，下标就是由关键码用散列函数计算出的散列地址。初始，指针数组每个元素为空指针，相当于所有单链表头指针为空，以后每扫描到一条记录，按其关键码的散列地址，在相应的单链表中加入含该记录的节点。开散列表容量可很大，仅受内存容量的限制。