## void

void即不确定类型。

因为类型不确定，从而内存不确定。

因此void类型不能声明实例对象。（void p = 10;不可以）

在C语言中，void的作用主要有以下两大类：

1. 对函数返回类型的限定，利用void对象的大小不确定来限制函数不能有任何返回值——这就是我们常写的void作返回值的函数。
2. 对函数参数类型的限定，当函数不允许接受参数是，必须用void来限定函数的参数——当然现在没什么会这么写了:`int func(void);`。

但`void*`则不同，编译器会允许你做类似于`int someInt = 10; void* par = &someInt;`之类的操作，因为无论指向什么类型的指针，指针本身所占空间是一定的。

我们可以认为`void*`就是一个通用指针，可以指向任意类型的指针。

我们都知道，指针有两个属性：指向变量/对象的地址和长度，**但是指针指存储被指向变量的地址，长度则取决于指针的类型**，编译器根据指针的类型从指针指向的地址向后寻址，不同的类型则寻址范围不同，如`int*`从指定地址向后寻找4字节作为变量的存储单元。

而我们将一个`void`类型的指针指向一个int类型的实例，**实际上是抹去了这一实例的类型信息**，因此在使用时我们要在心里清楚被抹去的类型信息。

基于这一特性，对于许多对内存进行操作的函数，`void*`会产生四两拨千斤的效果：

```cc
void* memcpy(void* dest, const void* src, size_t len);
void* memset(void* buffer, int c, size_t num);
```

对于没有泛型编程的C语言来说，任何类型的指针都可以传入`memcpy`和`memset`中，这也真实地体现了**内存操作函数**的意义，`void*`帮我们和编译器屏蔽了冗余的变量类型信息，而直接将内存暴露在我们面前。

对于C++而言，对于某些范型可以实现的功能但又想找一种轻量化的实现方法，`void*`也不失为一种不错的选择。

同时，基于这个特性，`void*`在使用时会不可避免的带来许多限制：

1. 如果将`void*`类型指针赋给其他类型指针，则需要强制类型转换：

   ```cpp
   int someInt = 10;
   void* pvoid = &someInt;
   int* pInt = (int*) pvoid;
   ```

2. void*指针不可解引用（取内容）：

   ```cpp
   int someInt = 10;
   void* pvoid = &someInt;
   *pvoid ++;	
   ```

3. 若想正确删除掉void*指向的动态类型变量，需要进行强制类型转换：

   在`delete`的过程中，编译器并不知道该`void*`指向的什么类型的变量，自然无法正确调用原类型的析构函数，因而只是**简单地清空了一个指针**。

   ```cpp
   delete voidPointer; 					//只是清空了一个指针
   delete (FrameInfo*) voidPointer; 		//正确析构voidPointer指向的变量。
   ```

