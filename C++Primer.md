1. main的返回值被用来指示状态，返回值0表示成功，非0的返回值的含义由系统定义，通常用来指出错误类型。
2. c++源文件后缀名：.cpp,.cc,.c,.cxx,.cp，不同编译器使用不同的后缀命名约定
3. 访问main的返回值的方法依赖于系统。echo命令可以获得返回值
    1. unix：echo ＄?
    2. windows：echo %ERRORLEVEL%
4. -std=c++0x 打开对c++11的支持
5. 输入流、输出流、文件流，“流”想表达的意思是，随着时间的推移，字符顺序生成或者消耗。
6. cin、cout、cerr(标准错误，输出警告和错误信息)、clog(输出程序运行时的一般性信息)
7. 通常情况下，#include指令必须出现在所有函数之外
8. 一个表达式产生一个计算结果，由一个或多个运算对象和一个运算符组成
9. 字符串字面值常量，用一对双引号包围的字符序列，也叫字符串常量，实际上是由常量字符构成的数组
10. 界定符注释时，注释内的每一行都以一个星号开头，注释界定符不能嵌套
11. 读取数量不定的输入数据while(cin>>val){}，一直到遇到文件结束符EOF，或者无效输入才停止读取
12. 键盘输入文件结束符EOF，
    1. unix：Ctrl+D
    2. windows：Ctrl+Z
13. 编译器没有能力检查一个程序是否按照其作者的意图工作，但可以检查形式上的错误
    1. 语法错误
    2. 类型错误
    3. 声明错误
14. 按照报告的顺序来逐个修正错误。在每修改一个错误后就立即重新编译代码。“编辑-编译-调试”周期
15. c++程序的缩进和格式，不存在唯一正确的风格，但是保持一致性是非常重要的
16. c++头文件后缀名：.h,.hpp,.hxx,.H，标准库头文件通常不带后缀
17. 从标准输入读入数据存于Book对象，Book book; cin>>book;将Book的内容写回标准输出，cout<<book;
18. 文件重定向，test <infile >outfile
19. 未初始化变量，未赋储值的变量。局部变量默认不初始化，除非有显式的初始化语句。未初始化变量是bug的常见成因。
20. linux区分大小写，java区分大小写。windows不区分大小写，c++不区分大小写。
21. 当函数不返回任何值时，使用空类型void作为返回值
22. 可寻址的最小内存块称为字节，存储的基本单位称为字。大多数机器的字节由8比特构成，字则由32/64比特构成
23. 当一个运算表达式既有无符号数又有有符号数，那么有符号数会转换成无符号数。无符号数不会小于零，小于零的无符号数表示数值总数取模后的余数
24. for(int i=0;i<n;i++){cout<<i}和int i=0;while(i<n){cout<<i;i++;}效果是一样的，但是while可以先i++再进行判断，for不行，int i=0;while(i<n){i++;cout<<i;}
25. 字面值常量，字面值常量的形式和值决定了它的数据类型。
    1. 整型字面值：21
    2. 浮点型字面值：3.14
    3. 字符字面值：'a'
    4. 字符串字面值："hello"
    5. 布尔字面值：true
    6. 指针字面值：nullptr
26. 字面值类型，可以用constexpr声明的类型。算数类型，引用，指针都属于字面值类型。constexpr指针初始化必须是constexpr或者0，或者是存储于某个固定地址(非局部变量)的对象。constexpr只对指针有效，对指针所指对象无效。constexpr int * p;是指针常量。
27. 指针，与引用类似，指针也实现了对其他对象的间接访问。指针和引用的不同点
    * 指针本身就是一个对象，允许对指针进行赋值和拷贝，并且在其生命周期内可以先后指向不同的对象
    * 指针无须在定义时赋初值，指针如果没有初始化，会拥有一个不确定的值

因为引用不是对象，没有地址，所以不能定义指向引用的指针

指针类型需要和它所指向的对象严格匹配，除了

    * 允许一个指向常量的指针指向非常量对象
    * 可以将基类的指针绑定到派生类对象上

指针值：指针的值即地址应属于下面四种状态之一

    * 指向一个对象
        * 解引用操作仅适用于指向一个对象的指针。
    * 指向紧邻对象所占空间的下一个位置
        * void*是一种特殊的指针类型，可用于存放任意对象的地址。不能直接操作void*指针所指对象
    * 空指针，意味着指针没有指向任何对象
        * int * p = nullptr;指针字面值
        * int * p = 0;字面值
        * int * p = NULL;预处理变量，预处理变量不属于std命名空间，编译前进行预处理。
    * 无效指针，即上述情况之外的其他值

建议初始化所有指针。

28. 对象：指一块能存储数据并具有某种类型的内存空间，对象和变量一般可以互换使用
29. 初始化：创建对象时赋予一个初始值。在在同一条定义语句中，可以用先定义的变量值去初始化后定义的变量。初始化不是赋值，赋值是把对象的当前值擦除后以一个新值替代。
    1. int a=0;
    2. int a={0};
    3. int a{0};列表初始化
    4. int a(0);

默认初始化：如果变量定义时没有指定初值，变量会被赋予默认值。全局变量默认值为0，局部变量不被初始化。

30. 分离式编译机制：允许将程序分割为若干个文件，每个文件可以独立编译。c++将声明和定义区分开来。extern声明变量。显式初始化的声明将成为定义。变量只能被定义一次，可以多次声明。
31. c++是一种静态类型语言，其含义是在编译阶段检查类型。检查类型的过程被称为类型检查。这要求我们在使用变量前必须声明其类型。
32. 引用：为对象起了另一个名字，引用类型引用另一种类型。引用必须被初始化。引用和其初始值绑定在一起，而不是将初始值拷贝给引用。引用即别名。引用不是对象，不能定义引用的引用。引用类型需要和它所绑定的对象严格匹配，引用只能绑定在对象上，不能与字面值或者表达式结果绑定。除了
    * 初始化常量引用时可允许用任意表达式作为初值，只要表达式结果能转换成引用的类型
    * 可以将基类的引用绑定到派生类对象上
33. 临时量对象：就是当编译器需要一个空间来暂存表达式的结果时临时创建的一个未命名对象。
34. 类型修饰符(*，&)只是用来修饰数据类型的。一条语句(同一数据类型)可以定义出不同类型的变量(修饰符不一样)。修饰符个数没有限制，可以有多个(int **p)
35. 没有指向引用的指针，但是有指向指针的引用（int *&r=p），相当于指针的别名。
36. const对象必须初始化，因为其一旦创建后就不能再改变(引用也是如此)。const对象只能执行不改变其内容的操作(可以用常量进行初始化，因为只是拷贝对象)。const默认状态下，仅在文件内有效。多文件共享const对象，必须在变量的定义和声明前加入extern。
37. 常量引用，指向常量的引用，const int & r;        常量指针，指向常量的指针，const int * p;         指针常量，指向本身是常量(引用不是对象，不能被const修饰)，int const * p;
38. 顶层const，表示指针本身是常量，如指针常量，类，算数类型；底层const，表示指针所指的对象是常量，如常量指针，引用。
39. 常量表达式是指值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式。constexpr变量一定是常量，且必须用常量表达式初始化，constexpr int m=20。可以用constexpr函数去初始化constexpr变量。
40. 类型别名。
    1. typedef int wag;
    2. using wag=int;别名声明
41. auto类型说明符，编译器自动分析表达式所属的类型，auto定义的变量必须要初始值。

auto有时候推导出来的类型和初始值类型不完全一样，编译器会适当地改变结果类型。引用作初始化时，auto a=r;返回的是int。

(const int ci=0)，auto忽略顶层const(auto a=ci)，底层const会保留(auto b=&ci)。希望auto是一个顶层const，需要明确指出(const auto c=ci)，还可以将引用的类型设为auto。

42. decltype类型指示符，选择并返回操作数的类型，编译器只得到其类型，不实际计算表达式的值。decltype(f())sum=x;sum的类型是f()的返回类型，但是并不调用f函数。

变量decltype(c)返回int，表达式如果是解引用decltype(*p)，返回的是引用类型int&。表达式如果是引用decltype(r)，返回int&,如果是decltype(r+0)，返回int。变量如果加()会被当成表达式返回&，decltype((c))返回int&。

43. 类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。
44. 预处理器，是在编译之前执行的一段程序，可以部分地改变我们所写的程序。预处理功能：
    1. #include，预处理器使用指定头文件的内容代替#include
    2. 头文件保护符，依赖于预处理变量，预处理变量有已定义和未定义两种状态。#define把一个名字设定为预处理变量，#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif。预处理变量无视作用域规则。
45. using声明，可以使用命名空间内的成员，比如using std ::cin;头文件中不应包含using声明。
46. string表示可变长的字符序列。拷贝初始化，使用等号去初始化一个变量，如string s2="huya";直接初始化，就是不使用等号去初始化变量，如string s3("huya");
47. 读取未知数量的string对象。string word;while(cin>>word){}使用getline去读取一整行string line;while(getline(cin,line)){}
48. size函数的返回值，size_type类型体现了标准库类型和机器无关的特性。它是一个无符号类型的值，并且能装得下任何string对象。
49. 字符串对象可以和字面值相加，字面值转成字符串类型。string s1="hello";string s2="world";string s3=s1+","+s2+'\n';必须确保连接符"+"的两侧运算符至少有一个是string类型。
50. math.h是c语言头文件，c++将其命名为cmath。区别就是cmath的头文件中定义的名字从属于命名空间std。
51. 范围for，遍历给定序列中的每个元素并对序列中的每个值执行某种操作。
52. []下标运算符接受的参数是size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上的引用。使用下标前需要确定该位置是否为空。使用下标时，最好这样使用：(decltype(s.sizd))index=0;下标运算符用于访问已存在的元素，不能用于添加元素。可以通过范围for循环确保下标合法。通过下标访问不存在的元素会产生很严重的后果，所谓的缓冲区溢出就是这类错误。
53. 使用{}来列表初始化,如vector<string> v{"hi","siri"};要想列表初始化，花括号里面的值必须与元素类型相同。
54. 如果循环体内有向vector对象添加元素的语句，则不能使用范围for循环。范围for循环不应该改变其遍历序列的大小。
55. 迭代器，类似指针，提供对对象的间接范围。迭代器有有效和无效之分。有效迭代器指向某个元素或者尾元素的下一个位置(尾后指针)，其他情况都是无效迭代器。尾后指针不能执行解引用和递增操作。使用了迭代器的循环体，不要向迭代器所属的容器添加数据，因为会导致迭代器失效。迭代器可以相减，返回值是名为difference_type的带符号整数。
56. 数组，大小确定不变，不能随意添加元素。不清楚元素的个数，使用vector。数组的纬度必须是一个常量表达式。数组的元素应该是对象，不存在引用的数组。可以使用列表初始化显式初始化数组元素，如int a[]={1,2};字符数组可以使用字符串字面值进行初始化，如char b[]="c++";数组也是对象，可以定义数组的引用和指针。
57. 数组的下标定义为size_t类型。size_t是一种机器相关的无符号类型，能装得下任意对象。
58. &取地址符获取指向某个对象的指针，因为数组的元素也是对象，所以可以对数组使用取地址符得到指向该元素的指针。编译器会将数组名替换成指向数组首元素的指针。使用数组对象就是使用一个指向该数组首元素的指针。使用auto推断出来的类型是指针，使用decltype推断出来的是数组。
59. 指针也可以像迭代器一样使用，int*b=arr;int*e=&arr[10];(获取尾后指针)为了让指针的使用更加安全简单，引入begin和end函数。int*b=begin(arr);int*e=end(arr);指针相减返回值类型是名为ptrdiff_td的带符号整数。
60. c风格字符串在c++中最好不要使用，因为很容易引发系统漏洞，是诸多安全问题的根本原因。字符串字面值是c风格字符串这一通用结构的实例。字符串存于字符数组并且以空字符结束。c风格字符串不能用<进行比较，这只是指针间在比较，应该使用strcmp函数。连接用strcat，拷贝用strcpy。还要考虑空间问题。
61. 混用string对象和c风格字符串。可以用c风格字符串作为=右侧运算对象，如string a="c++";加分允许其中一个是c风格字符串，a+"c++";不能用string对象直接初始化c风格字符串，可以使用c_str函数，const char *str=s.c_str();s改变，str就失效了，所以最好拷贝一份。
62. 数组不能为内置类型的数组赋初值，也不允许用vector对象初始化数组。但是可以用数组初始化vector对象。int arr[]; vector<int> v(begin(arr),end(arr);使用指针和数组很容易出错。所以应该尽可能使用vector和迭代器。应该尽可能使用string而不是c风格字符串。
63. 二维数组，其实是数组的数组,如int ia[3][4]。使用范围for处理二维数组，for(auto &row:ia)for(auto &col:row){}最外层必须是引用，因为不用引用，row会被编译器自动替换成指针，而不是数组。数组和指针，for(auto p=ia;p!=ia+3;p++)for(auto q=*p;q!=*p+4;q++){}类型别名简化二维数组的指针。
64. 表达式由一个或者多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。运算符重载时，运算对象的类型和返回值的类型由运算符确定，但是运算对象的个数和运算符的优先级和结合律无法改变。
65. 左值和右值。当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值时，用的是对象的身份（地址）。
66. 求值顺序。优先级规定了运算对象的组合方式，但是并没有说明运算对象按照什么顺序求值。比如int i =f1()*f2()。通过优先级可以知道f1和f2在乘法之前调用，但是谁先谁后并不知道。如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为，如int i=0;cout<<i<<++i;i和++i谁先谁后并不知道，因此表达式的行为不可预知。建议：多用括号，并且如果改变了某个运算对象的值，在表达式其他地方不要再使用这个运算对象。下面四种运算符明确了运算顺序：
    1. &&
    2. ||
    3. ?:
    4. ,
67. 向上取整：3.14变4，-3.14变-3。向下取整：3.14变3，-3.14变-4。向0取整(去掉小数)：3.14变3，-3.14变-3。取余运算：c=a/b;r=a-c*b；java/c++是向0取整，python是向下取整，处理正数时一样，处理负数有区别。
68. 相等性测试，测试一个算术对象或指针对象的真值。if(val)或者if(val==true)或者有个问题，就是只能用于val为布尔类型的情况，如果val为int，相当于if(val==1)所以建议第一种方法。
69. i++和++i。i++返回的是对象原始值的副本，++i返回的是对象本身。所以++i更加节省空间，提高性能。*i++，相当于*i;i+1。
70. sizeof运算符返回一条表达式或一个类型名字所占的字节数，返回值是size_t类型的常量表达式。sizeof并不实际计算其运算对象的值。对数组执行sizeof运算得到整个数组所占空间大小。
71. 逗号运算符。首先对左侧的表达式求值，然后将求值结果丢弃。逗号运算符真正的结果是右侧运算符的值。
72. 隐式转换。数组转换成指针。除了用于decltype，取地址符&，sizeof，typeid时仍然是对象。指针转换：常量整数值0或者字面值nullptr可以转成任意指针类型，指向任意非常量的指针能转换成void*，指向任意对象的指针能转换const void*。
73. 命名的强制转换。
    1. const_cat
    2. static_cast
    3. dynamic_cast
    4. reinterpret_cast

旧式强制类型转换

    1. type (expr)//函数形式
    2. (type) expr//c语言风格
74. 表达式加分号变成表达式语句，作用是执行表达式并丢掉求值结果。空语句(;)，空块({})。控制语句中声明的变量属于块内可见，且必须初始化。for语句定义的对象只在for循环体内可见。
75. 悬垂else问题，if对于else，else和谁匹配?else和最近的if匹配。使用花括号控制执行路径。
76. switch...case结构。switch后的表达式转换成整数类型(int/char)，然后和case标签的值做比较。case标签(case和值)必须是整数常量表达式。case标签的值不能相同。default标签，默认情况，最少加上空语句或者空块。
77. switch内部如果有变量定义，不允许跨过变量的初始化语句直接跳到该变量作用域内的另一个位置。所以变量应该定义在块内。
78. 当不清楚到底要迭代多少次，或者想在循环后访问循环控制变量时使用while循环。while的循环控制变量可以定义在while外面或者条件部分。do...while的循环控制变量只能定义在do外面。
79. 跳转语句：
    1. break
    2. continue
    3. goto
    4. return
80. 异常处理，当程序的某部分检测单一个它无法处理的问题时，需要异常处理。异常处理机制为程序中的异常检测和异常处理提供支持。
    1. throw表达式，异常检测，引发异常
    2. try语句块，包括catch子句(异常处理代码)
    3. 一套异常类
81. 在真实的程序中，应该把对象操作的代码和用户交互的代码分离开。所以使用try...catch捕获异常，和用户进行交互。如果最终没有找到匹配的catch语句，程序转到terminate库函数，一般情况下将导致程序非正常退出。没有定义try语句块的异常也是这处理。
82. 在异常发生期间正确执行了“处理”工作的程序被称为异常安全的代码。
83. 函数是一个命名了的代码块，我们可以通过调用函数来执行相应的代码。
84. 函数调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权从调用函数转移给被调用函数。此时主调函数的执行被暂时中断，被调函数开始执行。return语句也完成两项工作：一是返回return语句的值用来初始化调用表达式的结果，二是将控制权从被调函数转回主调函数。
85. 因为函数调用固定是实参和形参数量一致，所以形参一定会被初始化。实参必须能转换成形参。形参间不能同名，函数最外层作用域中的局部变量也不能使用和形参相同的名字。形参和函数体内定义的变量统称局部变量。
86. 函数返回值不能说数组或者函数类型，但是可以说指向数组或函数的指针。
87. 名字有作用域，对象有生命周期。
    1. 名字的作用域是程序文本的一部分，名字在其中可见。
    2. 对象的生命周期是程序在执行过程中该对象存在的一段时间。
88. 函数声明(函数原型)，在头文件中进行函数声明。在头文件声明变量。
89. 需要修改实参的值时，传引用；不需要改变实参的值时，传常量引用。一个函数只能返回一个值，当我们需要同时返回多个值时，可以给函数传入一个额外的引用形参保存另一个值。
90. const形参和实参
    1. 用实参初始化时也会忽略形参的顶层const。当形参有顶层const时，传给它常量或非常量对象都可以。f(int)和f(const int)可以传int，const int。
    2. 形参是非常量引用时，不能传常量或者字面值。f(int&)可以传int
    3. 形参是常量引用时，可以传字面值。f(const int&)可以传int，const int，50字面值
    4. 如果不修改实参，尽量使用常量引用，因为可以接受更多的实参类型。
91. 数组形参。数组有两个特殊性质：一是不能拷贝数组，二是数组名相当于指针。所以不能值传递，只能引用或者指针传递。f(int*a)和f(int a[])是一样的，数组的大小对函数的调用没有影响。因为不知道数组大小，所以需要管理指针数组（提供数组大小信息）：
    1. 使用标记指定数组长度，比如c风格字符串以空字符结束
    2. 使用标准库规范，传递指向数组首元素和尾元素的指针
    3. 显式传递一个表示数组长度的形参

形参可以是数组的引用。f(int (&a)[10])，这样只能给f传进有十个元素的数组。

传递二维数组。f(int (*a)[10]),或者f(int a[][10]),第一维度会被忽略，第二维度需要明确说明。

92. 命令行参数。int main(int argc,int *argv[])第一个参数argc是argv数组元素个数，第二个参数argv是指针数组，元素是指向c风格字符串的指针。数组第一个元素是文件名或者空串，后面的是命令行参数。最后一个指针之后的元素是0。
93. 返回类型。值返回，返回的是临时对象，或者拷贝。引用和指针返回的是原对象。除了局部对象必须值返回，其他都尽可能引用返回和指针返回。引用返回左值，返回非常量引用时可以再次赋值，其他都返回右值。可以使用列表(花括号包围的值)初始化返回值。main函数可以不写return语句，因为会隐式插入return 0;
94. 返回数组的指针或者引用。
    1. 类型别名typedef int a[10];//using a =int[10];

a* f(int i);

    2. 声明一个返回数组指针的函数int (*f(int))[10];
    3. 使用后置返回类型auto f(int i)->int(*)[10];
95. 函数重载，同名函数，看形参类型和数量，不看返回值类型。形参中，顶层const可以忽略，底层const不能忽略。函数匹配，重载确定，把函数调用和重载函数中的一个对应上。调用重载函数有三种情况：
    1. 找到一个最佳匹配，正确
    2. 没有找到匹配的，出错，无匹配
    3. 有多个可以匹配，没有最佳匹配，出错，二义性调用
96. 在内层作用域声明重载函数，会隐藏外层的重载函数。当内层作用域找到函数时，发现类型不同，返回错误，即使外层有匹配的重载函数。因为c++先进行名字查找，然后才进行类型匹配。所以重载函数声明应该放在同一个作用域。
97. inline内联函数在调用点内联地展开。constexpr函数，指用于常量表达式的函数，返回值和形参类型需要是字面值类型，并且函数有且只有一条return语句，隐式的内联函数。constexpr函数不一定返回常量表达式。这两个函数可以放在头文件定义。
98. assert预处理宏，其实是一个预处理变量，行为类似内联函数。assert(i>0);首先对表达式求值，如果表达式为0，assert输出信息并终止程序的执行。如果表达式为非0，assert什么也不做。assert的行为依赖与一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG（#define NDEBUG，或者-D NDEBUF），关闭调试状态，assert什么也不做。默认没有定义NEDEBUG。五个宏定义：
    1. __FILE__文件名
    2. __LINE__当前行号
    3. __TIME__编译时间
    4. __DATA__编译日期
    5. __func__函数名字
99. 函数匹配：确定应该调用哪个重载函数。
    1. 选定本次调用对应的重载函数集，集合中的函数称为候选函数。具备的特征：一是和被调用的函数同名，二是其声明在调用点可见。
    2. 根据实参选出可行函数。具备的特征：一是形参数量和实参数量相等，二是实参类型和形参类型相同，或者可以转换成形参类型。如果没找到，报告无匹配错误。
    3. 寻找最佳匹配，逐一检查函数调用提供的实参，寻找形参类型和实参类型最匹配的可行函数。如果有且只有一个函数满足下列条件，匹配成功：
        1. 该函数每个实参的匹配都不劣于其他可行函数需要的匹配
        2. 至少有一个实参的匹配优于其他可行函数提供的匹配。
    4. 如果没有一个可行函数脱颖而出，那么报告二义性调用错误。

调用重载函数应该尽量避免强制类型转换。

100. 实参类型转换，用于确定最佳匹配。
    1. 精确匹配。一是实参类型和形参相同，二是实参从数组类型或函数类型转换成对应的指针类型，三是向实参添加订餐const或从实参中删除顶层const
    2. 通过const转换实现的匹配
    3. 通过类型提升实现的匹配
    4. 通过算术类型转换或指针转换实现的匹配
    5. 通过类类型转换实现的匹配
101. 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是用户只能使用接口而无法访问实现部分。类的接口包括成员函数和类相关的普通函数。
102. this指针，指针常量，指针本身不能改变。成员函数通过this作为隐式参数访问调用的对象。对象的地址就是this的值。传给任何对类成员的直接访问都被看做this的隐式引用。返回对象本身用return *this;返回值类型为A&，返回对象的引用，返回的是左值。
103. 可以用int去初始化const int。但是不能用const int去初始化int。函数形参匹配利用到这个。常函数也用到这个。一般变量初始化也用到。
104. 常量成员函数，int f()const;const修饰的是this指针。默认情况下this类型是A * const。但是我们不能把绑定到常量对象上，这时需要把this定义成const A * const。通过在参数列表后面加const实现常函数。常函数不能改变对象的数据成员。常量对象以及常量对象的引用或指针只能调用常函数。
105. f(const) 说明形参不修改实参。f()const 说明不修改类数据成员。const f()说明返回值是常量。
106. 构造函数，如果需要使用默认构造函数可以使用a()default;要求编译器生成构造函数。构造函数初始化列表。构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值和原值不同。

初始化列表和类内初始化和构造函数体内赋值。

    1. 初始化列表，第一优先级。顺序是严格的。一般给数据成员初始化。
    2. 类内初始化，第二优先级。多个构造函数，类内初始化只写一次。顺序是隐式的。不可以(),只能=或者{}。给静态成员初始化。
    3. 构造函数体内赋值，第三优先级，尽量别用，因为类内初始化会使用默认初始化
107. 除了第一类的对象的初始化，类还需要控制拷贝，赋值和销毁对象时发生的行为。构造函数，拷贝构造函数，拷贝赋值函数，析构函数这些函数编译器都有默认函数。当类需要分配类对象之外的资源时，默认版本常常失效。



