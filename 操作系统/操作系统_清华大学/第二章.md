## 第二章

### 操作系统启动

OS存放在磁盘。然后由BIOS(基本I/O处理系统)提供相应支持。

BIOS作用：能够当我们一按电源后，让计算机系统开始检测各种各样的外设。然后才能加载相应的软件进行执行。

Bootloader存放在磁盘第一个主引导扇区，其功能是用来加载OS，从磁盘将OS加载到内存，然后让CPU可以执行操作系统。

BIOS第一步是从一个特定地址(CS:IP = F000:FFF0)开始执行。

CS:段寄存器，IP:指令寄存器

##### 步骤:

- BIOS第一个工作：POST(加电自检)，寻找显卡和执行BIOS

- BIOS将Bootloader从磁盘引导扇区(512字节)加载到内存0X7C00，并且跳转到CS:IP = 0000:7C00，启动Bootloader

- Bootloader将OS从磁盘加载到内存，并且跳转到操作系统的起始地址

### 中断、异常和系统调用

操作系统与设备和程序交互

面向外设是提供中断处理，面向应用程序是提供系统调用和异常

- 系统调用(来源于应用程序)：应用程序主动向操作系统发出服务请求
- 异常(来源于不良的应用程序)：非法指令或者其他坏的处理状态(如：内存出错)
- 中断(来源于外设)：来自不同的硬件设备的计时器和网络的中断

为什么应用程序不能直接访问外设呢？为什么要通过操作系统？

操作系统是一个特殊的系统软件，它具有对整个计算机系统的控制权，它可以执行特权指令，它是一个可信任的软件。通过操作系统可以给上层应用提供一个简单一致的接口

源头：

- 中断：外设
- 异常：应用程序意想不到的行为
- 系统调用：应用程序请求操作系统提供服务

处理时间：

- 中断：异步(不可预测)
- 异常：同步(可以预测)
- 系统调用：异步或同步

响应：

- 中断：持续，对用户应用程序是透明的
- 异常：杀死或者重新执行意想不到的应用程序指令
- 系统调用：等待和持续

中断和异常处理机制

- 中断是外设的事件
- 异常是内部CPU的事件
- 中断和异常迫使CPU访问一些被中断和异常服务访问的功能。

中断和异常的处理过程

硬件处理和软件处理

需要知道中断和异常是由哪一个特定的服务例程来服务，为此需要建立中断表，key是中断/异常号，value是对应的地址，这个地址是针对这个特定中断的服务例程的地址。

发生中断时，根据中断号，查找中断表，找到对应的中断例程的地址，然后跳转到该中断例程执行。

但是为了让整个系统还能继续正常工作，所以需要保存上下文环境。

##### 中断过程：

硬件：设置中断标记[CPU初始化]，根据中断标志可以产生中断号。

软件：保存当前状态，通过中断号，找到对应中断服务程序处理，消除中断标志，恢复之前保存的处理状态。

##### 异常过程：

- 产生异常编号

- 保存现场
- 异常处理
  - 杀死产生了异常的程序
  - 或重新执行异常指令
- 恢复现场

##### 系统调用

程序访问主要是通过高层的API接口，而不是直接进行系统调用

Windows：WIN32 API

UNIX：POSIX API

通常情况下，与每个系统调用相关的序号，系统调用接口根据这些序号来维护表的索引

系统调用接口调用内核态中预期的系统调用，并返回系统读的状态和其他任何返回值

用户不需要中断系统调用是如何实现的，只需要获取API和了解操作系统将什么作为返回结果，操作系统接口的细节大部分隐藏在API中，通过运行程序支持的库来管理

系统调用和函数调用的区别

当我们应用程序发出函数调用时，其实是在一个栈空间完成了参数传递和参数返回，但是系统调用和内核操作系统是有各自的调用，系统调用时，需要切换堆栈，需要用用户态转为内核态，需要一定的开销。

跨越操作系统边界的开销

- 在执行时间上的开销超过程序调用
- 开销
  - 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销
  - 建立内核堆栈
  - 验证参数
  - 内核态映射到用户态的地址空间，更新页面映射权限
  - 内核态独立空间