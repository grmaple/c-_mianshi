# 虚函数

https://blog.csdn.net/haoel/article/details/1948051

C++中的虚函数的作用主要是实现了多态的机制。

关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。

这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

### 虚函数

当一个类中包含被virtual 关键字修饰的成员函数时，该成员函数就成为了一个虚函数。

虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。

### 虚函数表

虚函数表： 同属一个类的不同的实例化对象其实是共用一张虚函数表的，在对象中含有一个虚函数指针 ***_vptr**, 该指针指向该类的虚函数表，虚函数表保存的是类中虚函数的地址（一个类可能有多个虚函数）。

##### **一般继承（无虚函数覆盖）**

![image-20200803115612782](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200803115612782.png)

1）虚函数按照其声明顺序放于表中。

2）父类的虚函数在子类的虚函数前面。

##### **一般继承（有虚函数覆盖）**

![image-20200803115604707](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200803115604707.png)

1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。

2）没有被覆盖的函数依旧。

当一个子类继承了一个含有虚函数的基类，并重写了该基类中的一个虚函数，我们就说这两个类构成多态。子类继承基类的同时，基类的虚函数表也被子类继承，不同的是被子类重写的虚函数将会替代原来虚函数表中对应的基类的虚函数的地址。从而基类与子类调用同名的虚函数时，所调用的就不是同一个函数，从而体现了多态和虚函数表的作用。

##### 多重继承（无虚函数覆盖）

<img src="C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200803115554188.png" alt="image-20200803115554188" style="zoom:67%;" />

1）  每个父类都有自己的虚表。

2）  子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）

##### 多重继承（有虚函数覆盖）

<img src="C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200803115546004.png" alt="image-20200803115546004" style="zoom: 67%;" />

*三个父类虚函数表中的*f()*的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的*f()*了。*

### 安全性

##### 一、通过父类型的指针访问子类自己的虚函数

任何妄图使用父类指针想调用子类中的**未覆盖父类的成员函数**的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。

##### 二、访问non-public的虚函数

另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。

### 为什么父类的析构函数必须是虚函数？

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，**防止内存泄漏。**

### 为什么C++默认的析构函数不是虚函数 

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，**占用额外的内存**。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是**只有当需要当作父类时，设置为虚函数。**

### 静态函数和虚函数的区别

https://blog.csdn.net/lovehang99/article/details/104617908

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

类的静态函数是没有this指针的，调用它时不需要创建对象，通过：类名 ：：函数名（参数）的形式直接调用。静态函数只有唯一的一份，因此它的地址是固定不变的， 所以编译的时候但凡遇到调用该静态函数的时候就知道调用的是哪一个函数，因此说**静态函数在编译的时候就已经确定运行时机。**

```cpp
class A
{
	public: 
	virtual void fun()
				{
						cout<<"i am A <<endl;
				}
}

class B: public A
{
	public:
	virtual  void  fun()
	{
			cout<<"I  am  B" <<endl;
		}
};
int main()
{
	A  a ;
	B b;
	A*  pb = &b;
	pb->fun();
	return 0; 
}

```

类A与类B构成多态，创建了 A类指针pb指向 B类对象，当程序编译的时候只对语法等进行检测，该语句没有什么问题，但是编译器此时无法确定调用的是哪一个 fun() 函数，因为类A类B中都含有fun函数，因此只能是在程序运行的时候通过 pb指针 查看对象的虚函数表（访问虚函数表就是所谓的访问内存）才能确定该函数的地址，即确定调用的是哪一个函数。这就解释了所说的“**虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制,调用的时候会增加一次内存开销。**”

### 多态

多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。

overload重载，编译时的多态 
override覆盖，运行时的多态

编译时的多态性为我们提供了运行速度快的特点，而运行时的多态性则带来了高度灵活和抽象的特点。

### 重载和覆盖

方法的覆盖是子类和父类之间的关系，是垂直关系；

方法的重载是同一个类中方法之间的关系，是水平关系。

重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
覆盖：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写/覆盖

### 虚函数在内存哪里?

如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。

如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。

如果类中成员是virtual属性，会隐藏父类对应的属性。

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA)

例如A* obj = new A;

obj是一个局部变量，类型为指针，存放在栈区；

通过new动态的在堆区申请类A大小的空间；

其中虚函数表指针在实例的最前面，也在堆中；

虚函数表在只读数据段中，里面存放着指向虚函数的指针；

虚函数实际代码在代码段中。