std::alloc运行模式

维护16条，16种大小的链表，free_list

8-128bytes

每条间隔8个bytes。申请6bytes会进入8bytes，都会调整到合适大小的。

超过大小的就调用malloc

allocate()

第一次申请32bytes，链表没有，系统会malloc分配20块32bytes内存块，并把第一块传回给客户。

其实这时候系统会多分配一块20*32bytes大小的内存池。

第二次申请64bytes，链表没有，系统在刚刚那个内存池分成10块64bytes内存块，并把第一块传回客户。

第三次申请96bytes，链表没有，并且没有内存池，系统malloc分配20*96\*2bytes，并把第一块传回客户。多出来的20\*96是内存池。

embedded pointers嵌入指针，不用多设计一个指针

![image-20210314113042917](https://i.loli.net/2021/03/14/GVXNI2icgynqz3L.png)

```c++
union obj{
  union obj*  free_list_link;
  char client_data[1];//没用到
};
//可以改成
struct obj{
  struct obj* free_list_link;  
};

```

一般对象都大于等于4bytes



```c
template<bool threads, int inst>
__default_alloc_template<threads, inst>::obj* volatile __default_alloc_template<threads, inst>::free_list[__NFREELISTS] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}//16个
typedef __default_alloc_template<false,0> alloc;
```

分配器的客户是容器而不是用户，用户尽量不要直接用分配器。

pool即内存池。start_free和end_free之间的内存即是内存池。

1.申请32bytes，由于pool为空，故索取并成功向pool注入32\*20*2+RoundUp(0>>4)=1280，从中切出一个区块返给客户，19个区块给list#3，余640备用。

累计申请量：1280，pool大小：640

2.申请64bytes，由于pool有余量，故取pool割分为640/64=10个区块，第一个给客户，余9个挂于list#7

累计申请量：1280，pool大小：0

从pool中切出来的区块，永远是1-20之间。

3.申请96，由于pool为空，故索取并成功向pool注入96\*20*2+RoundUp(1280>>4)=3920，从中切出一个区块返给客户，19个区块给list#11，余2000（96\*20+80）备用。

RoundUp是个函数，参数是个追加量，即累计申请量/16，然后函数作用是将追加量调到8的边界。所以申请量会越来越大。

累计申请量：5200，pool大小：2000

4.申请88，由于pool有余量，故取pool割分20个区块，第一个分给客户，余19个挂于list#10。pool余量：2000-88*20=240

累计申请量：5200，pool大小：240

5.连续申请三次88，直接从list#10取出三个返给客户。

累计申请量：5200，pool大小：240

6.申请8，由于pool有余量，故取pool割分成20个区块，第一个返回给客户，余19个挂于list#0，pool=240-8*20=80

累计申请量：5200，pool大小：80

7.申请104，list#12无区块，pool余量不足供应一个，于是先将pool余额拨给list#9（碎片处理），然后索取并成功获得注入104\*20*2+RoundUp(5200>>4)= 4488，切出19个挂于list#12，最头的那个返给客户，余2408备用。

累计申请量：9688，pool大小：2408

8.申请112，由于pool有余量，故取pool割分成20个区块，第一个返回给客户，余19个挂于list#0，pool=2408-112*20=168

累计申请量：9688，pool大小：168

9.申请48，由于pool有余量，从pool中取3个区块，头一个给客户，2个挂于list#5，pool=168-48*3

累计申请量：9688，pool大小：24

接下来假设系统容量为10000，我们探究内存分配失败时的情况。

10.申请72，list#8无可用区块，pool余量由不足以供应一个，于是向将pool余额24拨给list#2，然后索取72\*20*2+RoundUp(9688>>4)，但是系统无法满足此次索取，于是alloc从手中资源取最接近者之80（list#9）回填pool，再从中切出72返回给客户。poo=80-72=8 

累计申请量：9688，pool大小：8

11.申请72，list#8无可用区块，pool余量由不足以供应一个，于是向将pool余额8拨给list#0，然后索取72\*20*2+RoundUp(9688>>4)，但是系统无法满足此次索取，于是alloc从手中资源取最接近者之88（list#10）回填pool，再从中切出72返回给客户。poo=88-72=16

累计申请量：9688，pool大小：16

12.申请120，list#14无可用区块，pool余量由不足以供应一个，于是向将pool余额16拨给list#1，然后索取120\*20*2+RoundUp(9688>>4)，但是系统无法满足此次索取，于是alloc从手中资源取最接近者回填pool，但是找不到。

累计申请量：9688，pool大小：0

检讨1：alloc手上还有很多资源（之前分配挂在list上的区块），可不可以合并呢？技术难度很高，如何找到相邻的两块合并呢？

检讨2：系统堆中还有多少资源呢？10000-9688=312。可不可以将失败的那个请求量折半再折半一直到小于312呢？