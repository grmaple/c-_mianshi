# 阻塞、非阻塞、同步和异步

对CPU而言，IO阻塞是绝对的，因为所有设备都不会快过CPU。

内核给应用层提供访问这些IO的函数是阻塞的还是非阻塞的。

1. 阻塞和非阻塞是指内核提供给应用层的IO访问函数是等待IO结果返回还是立即返回，等待结果的就是阻塞函数，立即返回的就是非阻塞函数，是针对函数而言的。
2. 同步和异步是指应用层在调用内核的阻塞函数或非阻塞函数后采取的处理方式，是针对操作而言的。
3. 如果内核只提供阻塞IO函数，你的应用层操作必然是同步。
4. 如果内核也提供了非阻塞IO函数，你的应用层可能是同步，也可能是异步。
5. 如果内核没有提供IO完成通知机制，你的应用层也无法实现完全的异步。

这些函数和操作的组合就产生了不同的IO模型，或者说阻塞函数、非阻塞函数、同步操作、异步操作之间的组合就是IO模型。

同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。



非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。

非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，此时的性能提升是明显的。但非阻塞I/O也存在一些问题。由于完整的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做轮询。

阻塞I/O造成CPU等待浪费，非阻塞I/O带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费。



### IO模型

五种IO模型包括：**阻塞IO、非阻塞IO、信号驱动IO、IO多路转接、异步IO**。其中，前四个被称为同步IO。

##### 1.阻塞IO（blocking I/O）

在内核将数据准备好之前，系统调用会一直等待所有的套接字，默认的是阻塞方式。

![image-20210303102545060](https://i.loli.net/2021/03/03/3tRcIzXTNlO6UFw.png)

这个模型是我们最常见的，程序调用和我们编写的基本程序是一致的。

```
fd=connect();
write(fd);
read(fd);
close(fd);1234
```

程序的read必须在write之后执行，当write阻塞住了，read就不能执行下去，一直处于等待状态。

### 2.非阻塞IO（noblocking I/O）

每次客户询问内核是否有数据准备好，即文件描述符缓冲区是否就绪。当有数据报准备好时，就进行拷贝数据报的操作。当没有数据报准备好时，也不阻塞程序，内核直接返回未准备就绪的信号，等待用户程序的下一个轮询。

![image-20210303103855399](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20210303103855399.png)

### 3.信号驱动IO（signal blocking I/O）

信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。

![image-20210303103809003](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20210303103809003.png)

### 4.IO多路转接（I/O multiplexing）

IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。

其中，select只负责等，recvfrom只负责拷贝。
IO多路转接是属于阻塞IO，但可以对多个文件描述符进行阻塞监听，所以效率较阻塞IO的高。![image-20210303103827145](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20210303103827145.png)

### 5.异步IO（asynchronous I/O）

当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。

当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。

![](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20210303103653192.png)

### 总结

![image-20210303103630700](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20210303103630700.png)

**可以看出，阻塞程度：阻塞IO>非阻塞IO>多路转接IO>信号驱动IO>异步IO，效率是由低到高的**。

### 概念

**同步：**
所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。**也就是必须一件一件事做**,等前一件做完了才能做下一件事。

例如普通B/S模式（同步）：提交请求->等待服务器处理->处理完毕返回   这个期间客户端浏览器不能干任何事

**异步：**
异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

例如 ajax请求（异步）: 请求通过事件触发->服务器处理（这时浏览器仍然可以作其他事情）->处理完毕

**阻塞：**
阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。

有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。

**非阻塞**
非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

再简单点理解就是：

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）
3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者

同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞

阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回

综上可知，同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。