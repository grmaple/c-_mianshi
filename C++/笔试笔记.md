### 静态分配和动态分配

静态分配是指在编译阶段就能确定大小，由编译器进行分配，堆不可以进行静态分配，堆的申请都是在执行过程中进行的。

动态内存分配就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。

**堆都是动态分配的，没有静态分配的堆**。

栈有2种分配方式：静态分配和动态分配。

静态分配是编译器完成的，比如局部变量的分配。动态分配由函数alloca（）进行分配。**不过栈的动态分配和堆不同，他的动态分配是由编译器进行释放，无需我们手工实现。** 



malloc和free申请和释放的虚拟内存。

malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关。



c语言的标准内存分配函数有：malloc,calloc,realloc,free等。

c++的内存分配和释放函数为new和delete。



##### STL二级空间配置器

动态内存分配我们知道实际上底层都是调用malloc来实现的。而调用malloc分配内存的同时还会分配一些附加空间也就是比如cookie，频繁的在堆上开辟释放内存，会在堆上造成很多外部碎片。因此在申请大内存时我们才使用malloc，在申请内存<=128bytes时，我们调用二级空间配置器。

二级配置器维护了16条链表，最小8字节，每条链表以8字节逐渐递增。还使用了内存池，即每次先看看内存池是否为空，为空则malloc，否则从内存池分配内存给用户。

缺点是会引入内部碎片。因为申请的大小会提升为8字节。

### 构造函数调用顺序

 构造函数调用顺序：基类构造函数->子类成员变量构造函数->子类构造函数  

 析构函数调用顺序：子类析构函数->子类成员变量析构函数->基类析构函数 

组合派生类的构造函数构造顺序为：初始化基类成员->初始化新增对象成员->初始化新增非对象成员

同时组合派生类具有多个新增对象成员的时候，按照类中的声明顺序来初始化对象成员。

成员初始化列表同时出现对虚基类和非虚基类构造函数的调用时，虚基类的构造函数先于非虚基类的构造函数执行

### 字符串操作

strcpy执行时，会自动在复制后的字符串上添加‘\0’

### 运算符

\>> 算术右移 高位补符号位

\>>> 逻辑右移 高位补0



### 数组

① 数组名，是指向它的第一个一级成员的指针

② 数组名取地址，是指向整个数组的指针

int a[4];

a是指向a[0]的指针，类型是int*，存储的是首元素a[0]的地址即a==&a[0]，a+1指向a[1]

&a是指向整个数组的指针，类型是int(*p)[4]，&a+1指向a[4]



### 引用

空引用可用于访问静态变量或方法

1. 所引用对象是否为null无关紧要，因为访问静态方法不需要实例对象。 

2. 如果引用不为null，运行时对象类型也无关紧要，因为静态调用不会导致动态调用分派。而是与类相关。



###  宏定义

宏定义是**在编译器预处理阶段中就进行替换**了，替换成什么只与define和undefine的**位置有关系**，与它们**在哪个函数中无关**。



### 抽象类

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。

抽象类有以下几个特点：

（1）抽象类只能用作其他类的基类，不能建立抽象类对象。

（2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。

（3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。

## 构造函数知识点

### 构造函数体内初始化与列表初始化的区别

一个类A，如果它有一个类成员B是类类型的，那么，

如果A是通过构造函数体内初始化，则先隐式调用B的默认（无参）构造函数，再进入A的构造函数体内，调用B的赋值运算符。

如果A是通过列表初始化来初始化，则会显式调用B的拷贝构造函数

##### 以下几种情况必须使用初始化列表去初始化类成员：

1. const成员和引用成员
2. 类类型成员没有默认构造函数（只定义了其他的构造函数，编译器不通过默认构造函数）
3. 当子类初始化父类的私有成员，只能通过初始化列表，如果在构造函数内部赋值则会调用默认构造函数

##### 初始化列表和类内初始化和构造函数体内赋值

1. 初始化列表，第一优先级。顺序是严格的。一般给数据成员初始化。
2. 类内初始化，第二优先级。多个构造函数，类内初始化只写一次。顺序是隐式的。不可以(),只能=或者{}。给静态成员初始化。
3. 构造函数体内赋值，第三优先级，尽量别用，因为会先进行类内初始化（使用默认初始化），然后再赋值

##### 类对象的构造顺序

1.分配内存，先类内初始化各数据成员；

2.初始化列表在构造函数执行前执行

2.进入构造函数后在构造函数中执行一般赋值与计算。

### 构造函数是否可以定义为private

可以，这就是单例模式。

构造函数定义为private，则不能在类外访问这个构造函数，也就是不能在类外创建对象。

但是我们可以通过static公有成员（静态对象独立于类对象，不必产生对象也可以使用）new该类的对象（堆上创建对象，对象不会随着函数退出而释放），并以指针或引用形式返回（不返回值对象，因为外部不能创建临时对象）。

```c++
#include<iostream>
using namespace std;
class OnlyHeapClass{
public:
	static OnlyHeapClass* GetInstance(){
		// 创建一个OnlyHeapClass对象并返回其指针
		return (new OnlyHeapClass);
    }
	void Destroy(){ 
        delete this; 
	} 
private:
	OnlyHeapClass() {}
	~OnlyHeapClass() {}
};

int main()
{
       OnlyHeapClass *p = OnlyHeapClass::GetInstance();
       //... // 使用*p
	   p->Destroy();
       //delete p;
       return 0;
}
```

##### 析构函数定义为private

则不能通过栈生成对象，只能通过堆生成对象。

C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性（因为栈需要做到自动析构，所以需要检查析构函数的访问性，确保可以析构才在栈上创建对象）。若析构函数不可访问，则不能在栈上创建对象。

如何才能只在栈上生成对象？将 new 和 delete 重载为私有。

### 构造函数和析构函数是否可以为虚函数

##### 构造函数不可以为虚函数

从vptr角度来解释，因为虚函数是通过vtable虚函数表调用的，而类的实例化对象有一个vptr虚指针指向虚函数表。这个vptr指针是在构造函数中初始化的。如果构造函数为虚函数，则vptr此时还没生成，却要调用构造函数，这不合理。

从多态的角度来解释，因为虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建一个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。

##### 析构函数可以为虚函数。

在多态中，我们通常通过基类的指针来销毁对象。如果析构函数不为虚函数，而基类的指针指向子类时，则delete时只释放基类，不释放子类，造成内存泄露。

```c++
//虚看对象，是子类，调用子类析构函数，并且调用父类析构函数
//实看类型，是父类，调用父类析构函数
BaseClass* pObj = new SubClass();
delete pObj;//调用析构函数
```

析构函数不是虚函数的话，直接按指针类型调用该类型的析构函数代码，因为指针类型是基类，所以直接调用基类析构函数代码。

##### 什么时候调用析构函数

析构函数是在对象消亡时，自动被调用，用来释放对象占用的空间。

有四种方式会调用析构函数：

1.**生命周期**：对象**生命周期结束**，会调用析构函数。

2.**delete**：调用delete，会删除指针类对象。

3.**包含关系**：对象Dog是对象Person的成员，Person的析构函数被调用时，对象Dog的析构函数也被调用。

4.**继承关系**：当Person是Student的父类，调用Student的析构函数，会调用Person的析构函数。

## 关键字知识点

### 说明static的原理

首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. 

在全局变量前加static，全局变量变成全局静态变量，其作用域变成只有当前文件可以访问

在局部变量前加static，局部变量变成局部静态变量，改变了其存储位置用栈变成静态存储区，其生存期变成全局的。

在全局函数前加static，变成静态函数，静态函数只是在声明他的文件当中可见，不能被其他文件所用。

在成员函数前加static，变成静态成员函数，静态函数独立于类对象存在，没有this指针，只能调用static成员

在成员变量前加staic，变成静态成员变量，静态变量用对象共享，不能用构造函数初始化，只能在类外初始化。

##### 存储说明符

对应两种存储期：自动存储期（局部）和静态存储期（全局）。

- auto
  - 在c++11之前用来表示变量是一种自动型的变量，其存储的生命周期为一个函数或者代码块里，若不显式定义，默认为自动存储变量。
  - 而在c++11之后，auto被用作自动判别数据类型。
- register
  - 在c++11之前被定义为寄存器存储变量，使得访问和操作变量的速度更快。
  - 而在c++11被定义为显式表示变量是一种自动存储变量（同c++11之前定义的auto）。
- extern
  - 用extern说明变量需要在其他文件中查找，而这个extern只是一个声明而已，并没有创建一个内存单元来保存变量。
- static
  - 表示静态存储变量，只要定义过一次，便永久存储（直到程序结束），但是只能在一个函数体和代码块或者一个文件中使用。
- thread_local
  - c++11新增说明符，其存储变量的周期为一个线程，多用于多线程运作的程序。
- mutable
  - 用于结构体或类声明中，用于表示即使整个结构体或者类对象是被const限定了的，但是mutable说明的成员变量依然可以被改变。

##### cv限定符

- const限定符
  - const的使用比较广泛，可以用来定义常量，表示声明一种不可被修改的变量。
- volatile限定符
  - volatile限定符与const刚好相反，表示变量是容易变化的，即上一步赋值后，在下一步取值时不再是上一步的赋的值，经常用在嵌入式开发中，例如用变量来表示信号，而信号容易发生变化。

## 虚函数

### 静态绑定和动态绑定

- 静态类型：对象在声明时采用的类型，在编译期既已确定；
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

```c++
BaseClass* pObj = new SubClass();
//静态类型：BaseClass
//动态类型：SubClass
```

##### 静态绑定和动态绑定的区别：

1. 静态绑定发生在编译期，动态绑定发生在运行期；

2. 对象的动态类型可以更改，但是静态类型无法更改；

3. 要想实现动态，必须使用动态绑定；

4. 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；

### 静态函数可以声明为虚函数吗？

**静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰**

static成员函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义

虚函数依靠vptr指针来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，**静态成员函数没有this指针**，所以无法访问vptr。

### 虚函数可以被内联吗？

通常类成员函数都会被编译器考虑是否进行内联。 

但通过基类指针或者引用调用的虚函数必定不能被内联。 (多态性)

当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。

### 纯虚函数和抽象类

纯虚函数：没有函数体的虚函数

抽象类：包含纯虚函数的类

抽象类只能作为基类派生新类使用，不能创建抽象类的对象

如果我们不在派生类中覆盖所有纯虚函数，那么派生类也会变成抽象类

抽象类可以有构造函数，子类继承时构造函数调用。

### 虚函数可以是私有函数吗?

可以。

int main()必须声明为Base类的友元，否则编译失败。 编译器报错： 无法访问私有函数。 

当然，把基类声明为public， 继承类为private，该问题就不存在了。

