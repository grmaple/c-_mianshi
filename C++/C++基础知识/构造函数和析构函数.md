## 构造函数和析构函数

当定义一个类时，我们显式地或隐式地指定了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义拷贝控制成员函数来控制这些操作。

**拷贝控制成员**

1. 构造函数：定义了此类型的对象初始化时做什么
2. 拷贝构造函数：定义了当用同类型的另一个对象初始化新对象时做什么
3. 拷贝赋值运算符：定义了将一个对象赋予同类型的另一个对象时做什么
4. 移动构造函数：同拷贝构造函数，但是可以使用右值参数
5. 移动赋值运算符：同拷贝赋值运算符，但是可以使用右值参数
6. 析构函数：定义了此类型的对象销毁时做什么

### 三/五法则

三个基本操作：拷贝构造、拷贝赋值、析构，

两个移动操作：移动构造、移动赋值

所谓三/五法则，就是指将五个拷贝控制成员看作一个整体：一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。比如我们的 MyString 类，必须定义拷贝构造函数、拷贝赋值运算符以及析构函数才能正确工作（因为我们需要分配内存和释放内存，这些活编译器可不会为我们做）。拷贝一个资源会导致额外开销，在这种拷贝非必要的情况下，移动操作就可以避免这种开销。

```cpp
A a;//构造函数
//拷贝构造函数是针对一个未存在的对象进行初始化；
A b = a; //或者是A b(a)；调用拷贝构造函数，b还没存在  
A c;  
//拷贝赋值函数是针对已存在的对象进行初始化。
b = c; //调用拷贝赋值函数，b已经存在
```

### 构造函数

首先说一下一个C++的空类，编译器会加入哪些默认的成员函数

·默认构造函数和拷贝构造函数

·析构函数

·赋值函数（赋值运算符）

·取值函数

即使程序没定义任何成员，编译器也会插入以上的函数！ 

构造函数，又分为默认构造函数和自定义构造函数，其中默认构造函数包括：

1. 系统自动合成（没有构造函数时）

2. 无参构造函数

3. 全部带有默认实参的构造函数

   

### 拷贝构造函数

拷贝构造函数被自动调用执行的三种情况：

1）当用类的一个对象去初始化该类的另一个对象时

2）若函数的形参为类对象，调用函数，实参赋值给形参时，值传递

3）若函数的返回值是类的对象，函数执行完成返回调用时

什么时候编译器会生成默认的拷贝构造函数？

1）如果用户没有自定义拷贝构造函数，并且在代码中使用到了拷贝构造函数，编译器就会生成默认的拷贝构造函数。但如果用户定义了拷贝构造函数，编译器就不在生成。

2）如果用户定义了一个构造函数，但不是拷贝构造函数，而此时代码中又用到了拷贝构造函数，那编译器也会生成默认的拷贝构造函数。

```cpp
class Point
{
　　public:
　　　　Point(int xx=0,int yy=0)   //定义构造函数
      {
　　　　　　X=xx;
　　　　　　Y=yy;
　　　　}
　　　　Point(Point &p);   //声明拷贝构造函数
　　　　int GetX()  {return X;}
　　　　int GetY()  {return Y;}
　　private:
　　　　int X,Y;
};

Point::Point(Point &p)//定义拷贝构造函数
{
　　X=p.X;
　　Y=p.Y；
　　cout<<"拷贝构造函数被调用"<<endl;
}
```

##### 浅拷贝

由默认的拷贝构造函数将已有的对象的数据成员 赋值给同类的新对象的各数据成员来构造新对象的方法就是浅拷贝，也即是成员级拷贝。

浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用）

不足之处：

若用户未提供类的显示拷贝构造函数，而让系统去执行缺省的拷贝构造函数，只进行对象间的原样拷贝，从而使得两个不同对象的地址值完全相同，当对象被析构时，则会出现同一资源被释放了两次的错误。

```cpp
class A{
   int i;
};
class B{
   A *p;
public:
   B(){p=new A;}
   ~B(){delete p;}
};
void sayHello(B x){
}
int main(){
   B b;
   sayHello(b);
}
```

main函数里调用sayHello函数的时候，将b浅拷贝给了x，当sayHello函数执行完后，会调用析构函数释放掉p，而当main函数结束时，也会调用析构函数释放掉p，所以就会重复释放指针，导致程序崩溃。

##### 深拷贝

为了克服浅拷贝的不足，用户必须给出显式的拷贝构造函数，以实现“深拷贝”的功能：在拷贝构造函数中，首先要动态申请存储空间，并向该空间拷贝原对象的内容。

深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。

```cpp
person(person &p)
{
　　cout<<"copying"<<p.pName<<"into its own block"<<endl;
　　pName=new char[strlen(p.pName)+1];
   strcpy(pName,p.pName);
}
```

**总结：**浅拷贝就是指向同一个地址；深拷贝就是新开辟一个空间用于存储，也就是指向了两个不同的地址。

### 拷贝赋值函数

当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。

当没有重载赋值函数（赋值运算符）时，通过默认赋值函数来进行赋值操作。

赋值运算的重载声明如下：

 **A& operator = (const A& other)**

通常大家会对拷贝构造函数和赋值函数混淆，这儿仔细比较两者的区别：

1）拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。

2）一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象

3）实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。

所以如果类定义中有指针或引用变量或对象，为了避免潜在错误，最好重载拷贝构造函数和赋值函数。

##### 拷贝赋值函数的形参是引用传递，能否进行值传递

不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。如此循环，无法完成拷贝，栈也会满。

### 应用

**普通构造函数，拷贝构造函数，赋值函数的实现**

```cpp
String::String(const char* str)    //普通构造函数

{

 cout<<construct<<endl;

 if(str==NULL)        //如果str 为NULL，就存一个空字符串“”

{
 m_string=new char[1];
 *m_string ='\0';
}

 else

{

  m_string= new char[strlen(str)+1] ;   //分配空间
  strcpy(m_string,str);

}

}


String::String(const String&other)   //拷贝构造函数

{
 cout<<"copy construct"<<endl;
 m_string=new char[strlen(other.m_string)+1]; //分配空间并拷贝
 strcpy(m_string,other.m_string);
}

String & String::operator=(const String& other) //赋值运算符
{
 cout<<"operator =funtion"<<endl ;
 if(this==&other) //如果对象和other是用一个对象，直接返回本身
 {
  return *this;
 }
 delete []m_string; //先释放原来的内存
 m_string= new char[strlen(other.m_string)+1];
 strcpy(m_string,other.m_string);
 return * this;
}</span>
```

对象不存在，且没用别的对象来初始化，就是调用了构造函数

对象不存在，且用别的对象来初始化，就是拷贝构造函数

对象存在，用别的对象来给它赋值，就是赋值函数。

### 移动构造函数与移动拷贝运算符

所谓移动操作，实际上就是窃取资源，其不会分配任何资源，而是接管已经分配的内存（资源）

以类A为例，如果用a去初始化b，或者用a去赋值b，同时在初始化或者赋值后，b不再使用，则可以用移动构造函数/移动拷贝运算符，这两个函数的作用是用b去接管a中成员的内存空间，同时将a中的指针置空。

如果一个类定义了自己的拷贝控制成员（拷贝/移动/析构函数），那么编译器不会为该类合成两个移动函数，除非没有定义，所以如果没有移动构造函数，那么如果是一个右值那么也会调用拷贝构造函数，通过拷贝来构造

### 析构函数

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

析构函数释放资源的操作发生在析构函数体执行完以后，这和构造函数恰好相反（构造函数是先初始化然后执行构造函数体）

析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。

如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。

如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。