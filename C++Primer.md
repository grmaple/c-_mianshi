1. main的返回值被用来指示状态，返回值0表示成功，非0的返回值的含义由系统定义，通常用来指出错误类型。
2. c++源文件后缀名：.cpp,.cc,.c,.cxx,.cp，不同编译器使用不同的后缀命名约定
3. 访问main的返回值的方法依赖于系统。echo命令可以获得返回值
    1. unix：echo ＄?
    2. windows：echo %ERRORLEVEL%
4. -std=c++0x 打开对c++11的支持
5. 输入流、输出流、文件流，“流”想表达的意思是，随着时间的推移，字符顺序生成或者消耗。
6. cin、cout、cerr(标准错误，输出警告和错误信息)、clog(输出程序运行时的一般性信息)
7. 通常情况下，#include指令必须出现在所有函数之外
8. 一个表达式产生一个计算结果，由一个或多个运算对象和一个运算符组成
9. 字符串字面值常量，用一对双引号包围的字符序列，也叫字符串常量，实际上是由常量字符构成的数组
10. 界定符注释时，注释内的每一行都以一个星号开头，注释界定符不能嵌套
11. 读取数量不定的输入数据while(cin>>val){}，一直到遇到文件结束符EOF，或者无效输入才停止读取
12. 键盘输入文件结束符EOF，
    1. unix：Ctrl+D
    2. windows：Ctrl+Z
13. 编译器没有能力检查一个程序是否按照其作者的意图工作，但可以检查形式上的错误
    1. 语法错误
    2. 类型错误
    3. 声明错误
14. 按照报告的顺序来逐个修正错误。在每修改一个错误后就立即重新编译代码。“编辑-编译-调试”周期
15. c++程序的缩进和格式，不存在唯一正确的风格，但是保持一致性是非常重要的
16. c++头文件后缀名：.h,.hpp,.hxx,.H，标准库头文件通常不带后缀
17. 从标准输入读入数据存于Book对象，Book book; cin>>book;将Book的内容写回标准输出，cout<<book;
18. 文件重定向，test <infile >outfile
19. 未初始化变量，未赋储值的变量。局部变量默认不初始化，除非有显式的初始化语句。未初始化变量是bug的常见成因。
20. linux区分大小写，java区分大小写。windows不区分大小写，c++不区分大小写。
21. 当函数不返回任何值时，使用空类型void作为返回值
22. 可寻址的最小内存块称为字节，存储的基本单位称为字。大多数机器的字节由8比特构成，字则由32/64比特构成
23. 当一个运算表达式既有无符号数又有有符号数，那么有符号数会转换成无符号数。无符号数不会小于零，小于零的无符号数表示数值总数取模后的余数
24. for(int i=0;i<n;i++){cout<<i}和int i=0;while(i<n){cout<<i;i++;}效果是一样的，但是while可以先i++再进行判断，for不行，int i=0;while(i<n){i++;cout<<i;}
25. 字面值常量，字面值常量的形式和值决定了它的数据类型。
    1. 整型字面值：21
    2. 浮点型字面值：3.14
    3. 字符字面值：'a'
    4. 字符串字面值："hello"
    5. 布尔字面值：true
    6. 指针字面值：nullptr
26. 字面值类型，可以用constexpr声明的类型。算数类型，引用，指针都属于字面值类型。constexpr指针初始化必须是constexpr或者0，或者是存储于某个固定地址(非局部变量)的对象。constexpr只对指针有效，对指针所指对象无效。constexpr int * p;是指针常量。
27. 指针，与引用类似，指针也实现了对其他对象的间接访问。指针和引用的不同点
    * 指针本身就是一个对象，允许对指针进行赋值和拷贝，并且在其生命周期内可以先后指向不同的对象
    * 指针无须在定义时赋初值，指针如果没有初始化，会拥有一个不确定的值

因为引用不是对象，没有地址，所以不能定义指向引用的指针

指针类型需要和它所指向的对象严格匹配，除了

    * 允许一个指向常量的指针指向非常量对象
    * 可以将基类的指针绑定到派生类对象上

指针值：指针的值即地址应属于下面四种状态之一

    * 指向一个对象
        * 解引用操作仅适用于指向一个对象的指针。
    * 指向紧邻对象所占空间的下一个位置
        * void*是一种特殊的指针类型，可用于存放任意对象的地址。不能直接操作void*指针所指对象
    * 空指针，意味着指针没有指向任何对象
        * int * p = nullptr;指针字面值
        * int * p = 0;字面值
        * int * p = NULL;预处理变量，预处理变量不属于std命名空间，编译前进行预处理。
    * 无效指针，即上述情况之外的其他值

建议初始化所有指针。

28. 对象：指一块能存储数据并具有某种类型的内存空间，对象和变量一般可以互换使用
29. 初始化：创建对象时赋予一个初始值。在在同一条定义语句中，可以用先定义的变量值去初始化后定义的变量。初始化不是赋值，赋值是把对象的当前值擦除后以一个新值替代。
    1. int a=0;
    2. int a={0};
    3. int a{0};列表初始化
    4. int a(0);

默认初始化：如果变量定义时没有指定初值，变量会被赋予默认值。全局变量默认值为0，局部变量不被初始化。

30. 分离式编译机制：允许将程序分割为若干个文件，每个文件可以独立编译。c++将声明和定义区分开来。extern声明变量。显式初始化的声明将成为定义。变量只能被定义一次，可以多次声明。
31. c++是一种静态类型语言，其含义是在编译阶段检查类型。检查类型的过程被称为类型检查。这要求我们在使用变量前必须声明其类型。
32. 引用：为对象起了另一个名字，引用类型引用另一种类型。引用必须被初始化。引用和其初始值绑定在一起，而不是将初始值拷贝给引用。引用即别名。引用不是对象，不能定义引用的引用。引用类型需要和它所绑定的对象严格匹配，引用只能绑定在对象上，不能与字面值或者表达式结果绑定。除了
    * 初始化常量引用时可允许用任意表达式作为初值，只要表达式结果能转换成引用的类型
    * 可以将基类的引用绑定到派生类对象上
33. 临时量对象：就是当编译器需要一个空间来暂存表达式的结果时临时创建的一个未命名对象。
34. 类型修饰符(*，&)只是用来修饰数据类型的。一条语句(同一数据类型)可以定义出不同类型的变量(修饰符不一样)。修饰符个数没有限制，可以有多个(int **p)
35. 没有指向引用的指针，但是有指向指针的引用（int *&r=p），相当于指针的别名。
36. const对象必须初始化，因为其一旦创建后就不能再改变(引用也是如此)。const对象只能执行不改变其内容的操作(可以用常量进行初始化，因为只是拷贝对象)。const默认状态下，仅在文件内有效。多文件共享const对象，必须在变量的定义和声明前加入extern。
37. 常量引用，指向常量的引用，const int & r;        常量指针，指向常量的指针，const int * p;         指针常量，指向本身是常量(引用不是对象，不能被const修饰)，int const * p;
38. 顶层const，表示指针本身是常量，如指针常量，类，算数类型；底层const，表示指针所指的对象是常量，如常量指针，引用。
39. 常量表达式是指值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式。constexpr变量一定是常量，且必须用常量表达式初始化，constexpr int m=20。可以用constexpr函数去初始化constexpr变量。
40. 类型别名。
    1. typedef int wag;
    2. using wag=int;别名声明
41. auto类型说明符，编译器自动分析表达式所属的类型，auto定义的变量必须要初始值。

auto有时候推导出来的类型和初始值类型不完全一样，编译器会适当地改变结果类型。引用作初始化时，auto a=r;返回的是int。

(const int ci=0)，auto忽略顶层const(auto a=ci)，底层const会保留(auto b=&ci)。希望auto是一个顶层const，需要明确指出(const auto c=ci)，还可以将引用的类型设为auto。

42. decltype类型指示符，选择并返回操作数的类型，编译器只得到其类型，不实际计算表达式的值。decltype(f())sum=x;sum的类型是f()的返回类型，但是并不调用f函数。

变量decltype(c)返回int，表达式如果是解引用decltype(*p)，返回的是引用类型int&。表达式如果是引用decltype(r)，返回int&,如果是decltype(r+0)，返回int。变量如果加()会被当成表达式返回&，decltype((c))返回int&。

43. 类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。
44. 预处理器，是在编译之前执行的一段程序，可以部分地改变我们所写的程序。预处理功能：
    1. #include，预处理器使用指定头文件的内容代替#include
    2. 头文件保护符，依赖于预处理变量，预处理变量有已定义和未定义两种状态。#define把一个名字设定为预处理变量，#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif。预处理变量无视作用域规则。
45. using声明，可以使用命名空间内的成员，比如using std ::cin;头文件中不应包含using声明。
46. string表示可变长的字符序列。拷贝初始化，使用等号去初始化一个变量，如string s2="huya";直接初始化，就是不使用等号去初始化变量，如string s3("huya");
47. 读取未知数量的string对象。string word;while(cin>>word){}使用getline去读取一整行string line;while(getline(cin,line)){}
48. size函数的返回值，size_type类型体现了标准库类型和机器无关的特性。它是一个无符号类型的值，并且能装得下任何string对象。
49. 字符串对象可以和字面值相加，字面值转成字符串类型。string s1="hello";string s2="world";string s3=s1+","+s2+'\n';必须确保连接符"+"的两侧运算符至少有一个是string类型。
50. math.h是c语言头文件，c++将其命名为cmath。区别就是cmath的头文件中定义的名字从属于命名空间std。
51. 范围for，遍历给定序列中的每个元素并对序列中的每个值执行某种操作。
52. []下标运算符接受的参数是size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上的引用。使用下标前需要确定该位置是否为空。使用下标时，最好这样使用：(decltype(s.sizd))index=0;下标运算符用于访问已存在的元素，不能用于添加元素。可以通过范围for循环确保下标合法。通过下标访问不存在的元素会产生很严重的后果，所谓的缓冲区溢出就是这类错误。
53. 使用{}来列表初始化,如vector<string> v{"hi","siri"};要想列表初始化，花括号里面的值必须与元素类型相同。
54. 如果循环体内有向vector对象添加元素的语句，则不能使用范围for循环。范围for循环不应该改变其遍历序列的大小。
55. 迭代器，类似指针，提供对对象的间接范围。迭代器有有效和无效之分。有效迭代器指向某个元素或者尾元素的下一个位置(尾后指针)，其他情况都是无效迭代器。尾后指针不能执行解引用和递增操作。使用了迭代器的循环体，不要向迭代器所属的容器添加数据，因为会导致迭代器失效。迭代器可以相减，返回值是名为difference_type的带符号整数。
56. 数组，大小确定不变，不能随意添加元素。不清楚元素的个数，使用vector。数组的纬度必须是一个常量表达式。数组的元素应该是对象，不存在引用的数组。可以使用列表初始化显式初始化数组元素，如int a[]={1,2};字符数组可以使用字符串字面值进行初始化，如char b[]="c++";数组也是对象，可以定义数组的引用和指针。
57. 数组的下标定义为size_t类型。size_t是一种机器相关的无符号类型，能装得下任意对象。
58. &取地址符获取指向某个对象的指针，因为数组的元素也是对象，所以可以对数组使用取地址符得到指向该元素的指针。编译器会将数组名替换成指向数组首元素的指针。使用数组对象就是使用一个指向该数组首元素的指针。使用auto推断出来的类型是指针，使用decltype推断出来的是数组。
59. 指针也可以像迭代器一样使用，int*b=arr;int*e=&arr[10];(获取尾后指针)为了让指针的使用更加安全简单，引入begin和end函数。int*b=begin(arr);int*e=end(arr);指针相减返回值类型是名为ptrdiff_td的带符号整数。
60. c风格字符串在c++中最好不要使用，因为很容易引发系统漏洞，是诸多安全问题的根本原因。字符串字面值是c风格字符串这一通用结构的实例。字符串存于字符数组并且以空字符结束。c风格字符串不能用<进行比较，这只是指针间在比较，应该使用strcmp函数。连接用strcat，拷贝用strcpy。还要考虑空间问题。
61. 混用string对象和c风格字符串。可以用c风格字符串作为=右侧运算对象，如string a="c++";加分允许其中一个是c风格字符串，a+"c++";不能用string对象直接初始化c风格字符串，可以使用c_str函数，const char *str=s.c_str();s改变，str就失效了，所以最好拷贝一份。
62. 数组不能为内置类型的数组赋初值，也不允许用vector对象初始化数组。但是可以用数组初始化vector对象。int arr[]; vector<int> v(begin(arr),end(arr);使用指针和数组很容易出错。所以应该尽可能使用vector和迭代器。应该尽可能使用string而不是c风格字符串。
63. 



