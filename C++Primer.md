1. main的返回值被用来指示状态，返回值0表示成功，非0的返回值的含义由系统定义，通常用来指出错误类型。
2. c++源文件后缀名：.cpp,.cc,.c,.cxx,.cp，不同编译器使用不同的后缀命名约定
3. 访问main的返回值的方法依赖于系统。echo命令可以获得返回值
    1. unix：echo ＄?
    2. windows：echo %ERRORLEVEL%
4. -std=c++0x 打开对c++11的支持
5. 输入流、输出流、文件流，“流”想表达的意思是，随着时间的推移，字符顺序生成或者消耗。
6. cin、cout、cerr(标准错误，输出警告和错误信息)、clog(输出程序运行时的一般性信息)
7. 通常情况下，#include指令必须出现在所有函数之外
8. 一个表达式产生一个计算结果，由一个或多个运算对象和一个运算符组成
9. 字符串字面值常量，用一对双引号包围的字符序列，也叫字符串常量，实际上是由常量字符构成的数组
10. 界定符注释时，注释内的每一行都以一个星号开头，注释界定符不能嵌套
11. 读取数量不定的输入数据while(cin>>val){}，一直到遇到文件结束符EOF，或者无效输入才停止读取
12. 键盘输入文件结束符EOF，
    1. unix：Ctrl+D
    2. windows：Ctrl+Z
13. 编译器没有能力检查一个程序是否按照其作者的意图工作，但可以检查形式上的错误
    1. 语法错误
    2. 类型错误
    3. 声明错误
14. 按照报告的顺序来逐个修正错误。在每修改一个错误后就立即重新编译代码。“编辑-编译-调试”周期
15. c++程序的缩进和格式，不存在唯一正确的风格，但是保持一致性是非常重要的
16. c++头文件后缀名：.h,.hpp,.hxx,.H，标准库头文件通常不带后缀
17. 从标准输入读入数据存于Book对象，Book book; cin>>book;将Book的内容写回标准输出，cout<<book;
18. 文件重定向，test <infile >outfile
19. 未初始化变量，未赋储值的变量。局部变量默认不初始化，除非有显式的初始化语句。未初始化变量是bug的常见成因。
20. linux区分大小写，java区分大小写。windows不区分大小写，c++不区分大小写。
21. 当函数不返回任何值时，使用空类型void作为返回值
22. 可寻址的最小内存块称为字节，存储的基本单位称为字。大多数机器的字节由8比特构成，字则由32/64比特构成
23. 当一个运算表达式既有无符号数又有有符号数，那么有符号数会转换成无符号数。无符号数不会小于零，小于零的无符号数表示数值总数取模后的余数
24. for(int i=0;i<n;i++){cout<<i}和int i=0;while(i<n){cout<<i;i++;}效果是一样的，但是while可以先i++再进行判断，for不行，int i=0;while(i<n){i++;cout<<i;}
25. 字面值常量，字面值常量的形式和值决定了它的数据类型。
    1. 整型字面值：21
    2. 浮点型字面值：3.14
    3. 字符字面值：'a'
    4. 字符串字面值："hello"
    5. 布尔字面值：true
    6. 指针字面值：nullptr
26. 字面值类型，可以用constexpr声明的类型。算数类型，引用，指针都属于字面值类型。constexpr指针初始化必须是constexpr或者0，或者是存储于某个固定地址(非局部变量)的对象。constexpr只对指针有效，对指针所指对象无效。constexpr int * p;是指针常量。
27. 指针，与引用类似，指针也实现了对其他对象的间接访问。指针和引用的不同点
    * 指针本身就是一个对象，允许对指针进行赋值和拷贝，并且在其生命周期内可以先后指向不同的对象
    * 指针无须在定义时赋初值，指针如果没有初始化，会拥有一个不确定的值

因为引用不是对象，没有地址，所以不能定义指向引用的指针

指针类型需要和它所指向的对象严格匹配，除了

    * 允许一个指向常量的指针指向非常量对象
    * 可以将基类的指针绑定到派生类对象上

指针值：指针的值即地址应属于下面四种状态之一

    * 指向一个对象
        * 解引用操作仅适用于指向一个对象的指针。
    * 指向紧邻对象所占空间的下一个位置
        * void*是一种特殊的指针类型，可用于存放任意对象的地址。不能直接操作void*指针所指对象
    * 空指针，意味着指针没有指向任何对象
        * int * p = nullptr;指针字面值
        * int * p = 0;字面值
        * int * p = NULL;预处理变量，预处理变量不属于std命名空间，编译前进行预处理。
    * 无效指针，即上述情况之外的其他值

建议初始化所有指针。

28. 对象：指一块能存储数据并具有某种类型的内存空间，对象和变量一般可以互换使用
29. 初始化：创建对象时赋予一个初始值。在在同一条定义语句中，可以用先定义的变量值去初始化后定义的变量。初始化不是赋值，赋值是把对象的当前值擦除后以一个新值替代。
    1. int a=0;
    2. int a={0};
    3. int a{0};列表初始化
    4. int a(0);

默认初始化：如果变量定义时没有指定初值，变量会被赋予默认值。全局变量默认值为0，局部变量不被初始化。

30. 分离式编译机制：允许将程序分割为若干个文件，每个文件可以独立编译。c++将声明和定义区分开来。extern声明变量。显式初始化的声明将成为定义。变量只能被定义一次，可以多次声明。
31. c++是一种静态类型语言，其含义是在编译阶段检查类型。检查类型的过程被称为类型检查。这要求我们在使用变量前必须声明其类型。
32. 引用：为对象起了另一个名字，引用类型引用另一种类型。引用必须被初始化。引用和其初始值绑定在一起，而不是将初始值拷贝给引用。引用即别名。引用不是对象，不能定义引用的引用。引用类型需要和它所绑定的对象严格匹配，引用只能绑定在对象上，不能与字面值或者表达式结果绑定。除了
    * 初始化常量引用时可允许用任意表达式作为初值，只要表达式结果能转换成引用的类型
    * 可以将基类的引用绑定到派生类对象上
33. 临时量对象：就是当编译器需要一个空间来暂存表达式的结果时临时创建的一个未命名对象。
34. 类型修饰符(*，&)只是用来修饰数据类型的。一条语句(同一数据类型)可以定义出不同类型的变量(修饰符不一样)。修饰符个数没有限制，可以有多个(int **p)
35. 没有指向引用的指针，但是有指向指针的引用（int *&r=p），相当于指针的别名。
36. const对象必须初始化，因为其一旦创建后就不能再改变(引用也是如此)。const对象只能执行不改变其内容的操作(可以用常量进行初始化，因为只是拷贝对象)。const默认状态下，仅在文件内有效。多文件共享const对象，必须在变量的定义和声明前加入extern。
37. 常量引用，指向常量的引用，const int & r;        常量指针，指向常量的指针，const int * p;         指针常量，指向本身是常量(引用不是对象，不能被const修饰)，int const * p;
38. 顶层const，表示指针本身是常量，如指针常量，类，算数类型；底层const，表示指针所指的对象是常量，如常量指针，引用。
39. 常量表达式是指值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式。constexpr变量一定是常量，且必须用常量表达式初始化，constexpr int m=20。可以用constexpr函数去初始化constexpr变量。
40. 类型别名。
    1. typedef int wag;
    2. using wag=int;别名声明
41. auto类型说明符，编译器自动分析表达式所属的类型，auto定义的变量必须要初始值。

auto有时候推导出来的类型和初始值类型不完全一样，编译器会适当地改变结果类型。引用作初始化时，auto a=r;返回的是int。

(const int ci=0)，auto忽略顶层const(auto a=ci)，底层const会保留(auto b=&ci)。希望auto是一个顶层const，需要明确指出(const auto c=ci)，还可以将引用的类型设为auto。

42. decltype类型指示符，选择并返回操作数的类型，编译器只得到其类型，不实际计算表达式的值。decltype(f())sum=x;sum的类型是f()的返回类型，但是并不调用f函数。

变量decltype(c)返回int，表达式如果是解引用decltype(*p)，返回的是引用类型int&。表达式如果是引用decltype(r)，返回int&,如果是decltype(r+0)，返回int。变量如果加()会被当成表达式返回&，decltype((c))返回int&。

43. 类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。
44. 预处理器，是在编译之前执行的一段程序，可以部分地改变我们所写的程序。预处理功能：
    1. #include，预处理器使用指定头文件的内容代替#include
    2. 头文件保护符，依赖于预处理变量，预处理变量有已定义和未定义两种状态。#define把一个名字设定为预处理变量，#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif。预处理变量无视作用域规则。
45. using声明，可以使用命名空间内的成员，比如using std ::cin;头文件中不应包含using声明。
46. string表示可变长的字符序列。拷贝初始化，使用等号去初始化一个变量，如string s2="huya";直接初始化，就是不使用等号去初始化变量，如string s3("huya");
47. 读取未知数量的string对象。string word;while(cin>>word){}使用getline去读取一整行string line;while(getline(cin,line)){}
48. size函数的返回值，size_type类型体现了标准库类型和机器无关的特性。它是一个无符号类型的值，并且能装得下任何string对象。
49. 字符串对象可以和字面值相加，字面值转成字符串类型。string s1="hello";string s2="world";string s3=s1+","+s2+'\n';必须确保连接符"+"的两侧运算符至少有一个是string类型。
50. math.h是c语言头文件，c++将其命名为cmath。区别就是cmath的头文件中定义的名字从属于命名空间std。
51. 范围for，遍历给定序列中的每个元素并对序列中的每个值执行某种操作。
52. []下标运算符接受的参数是size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上的引用。使用下标前需要确定该位置是否为空。使用下标时，最好这样使用：(decltype(s.sizd))index=0;下标运算符用于访问已存在的元素，不能用于添加元素。可以通过范围for循环确保下标合法。通过下标访问不存在的元素会产生很严重的后果，所谓的缓冲区溢出就是这类错误。
53. 使用{}来列表初始化,如vector<string> v{"hi","siri"};要想列表初始化，花括号里面的值必须与元素类型相同。
54. 如果循环体内有向vector对象添加元素的语句，则不能使用范围for循环。范围for循环不应该改变其遍历序列的大小。
55. 迭代器，类似指针，提供对对象的间接范围。迭代器有有效和无效之分。有效迭代器指向某个元素或者尾元素的下一个位置(尾后指针)，其他情况都是无效迭代器。尾后指针不能执行解引用和递增操作。使用了迭代器的循环体，不要向迭代器所属的容器添加数据，因为会导致迭代器失效。迭代器可以相减，返回值是名为difference_type的带符号整数。
56. 数组，大小确定不变，不能随意添加元素。不清楚元素的个数，使用vector。数组的纬度必须是一个常量表达式。数组的元素应该是对象，不存在引用的数组。可以使用列表初始化显式初始化数组元素，如int a[]={1,2};字符数组可以使用字符串字面值进行初始化，如char b[]="c++";数组也是对象，可以定义数组的引用和指针。
57. 数组的下标定义为size_t类型。size_t是一种机器相关的无符号类型，能装得下任意对象。
58. &取地址符获取指向某个对象的指针，因为数组的元素也是对象，所以可以对数组使用取地址符得到指向该元素的指针。编译器会将数组名替换成指向数组首元素的指针。使用数组对象就是使用一个指向该数组首元素的指针。使用auto推断出来的类型是指针，使用decltype推断出来的是数组。
59. 指针也可以像迭代器一样使用，int*b=arr;int*e=&arr[10];(获取尾后指针)为了让指针的使用更加安全简单，引入begin和end函数。int*b=begin(arr);int*e=end(arr);指针相减返回值类型是名为ptrdiff_td的带符号整数。
60. c风格字符串在c++中最好不要使用，因为很容易引发系统漏洞，是诸多安全问题的根本原因。字符串字面值是c风格字符串这一通用结构的实例。字符串存于字符数组并且以空字符结束。c风格字符串不能用<进行比较，这只是指针间在比较，应该使用strcmp函数。连接用strcat，拷贝用strcpy。还要考虑空间问题。
61. 混用string对象和c风格字符串。可以用c风格字符串作为=右侧运算对象，如string a="c++";加分允许其中一个是c风格字符串，a+"c++";不能用string对象直接初始化c风格字符串，可以使用c_str函数，const char *str=s.c_str();s改变，str就失效了，所以最好拷贝一份。
62. 数组不能为内置类型的数组赋初值，也不允许用vector对象初始化数组。但是可以用数组初始化vector对象。int arr[]; vector<int> v(begin(arr),end(arr);使用指针和数组很容易出错。所以应该尽可能使用vector和迭代器。应该尽可能使用string而不是c风格字符串。
63. 二维数组，其实是数组的数组,如int ia[3][4]。使用范围for处理二维数组，for(auto &row:ia)for(auto &col:row){}最外层必须是引用，因为不用引用，row会被编译器自动替换成指针，而不是数组。数组和指针，for(auto p=ia;p!=ia+3;p++)for(auto q=*p;q!=*p+4;q++){}类型别名简化二维数组的指针。
64. 表达式由一个或者多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。运算符重载时，运算对象的类型和返回值的类型由运算符确定，但是运算对象的个数和运算符的优先级和结合律无法改变。
65. 左值和右值。当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值时，用的是对象的身份（地址）。
66. 求值顺序。优先级规定了运算对象的组合方式，但是并没有说明运算对象按照什么顺序求值。比如int i =f1()*f2()。通过优先级可以知道f1和f2在乘法之前调用，但是谁先谁后并不知道。如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为，如int i=0;cout<<i<<++i;i和++i谁先谁后并不知道，因此表达式的行为不可预知。建议：多用括号，并且如果改变了某个运算对象的值，在表达式其他地方不要再使用这个运算对象。下面四种运算符明确了运算顺序：
    1. &&
    2. ||
    3. ?:
    4. ,
67. 向上取整：3.14变4，-3.14变-3。向下取整：3.14变3，-3.14变-4。向0取整(去掉小数)：3.14变3，-3.14变-3。取余运算：c=a/b;r=a-c*b；java/c++是向0取整，python是向下取整，处理正数时一样，处理负数有区别。
68. 相等性测试，测试一个算术对象或指针对象的真值。if(val)或者if(val==true)或者有个问题，就是只能用于val为布尔类型的情况，如果val为int，相当于if(val==1)所以建议第一种方法。
69. i++和++i。i++返回的是对象原始值的副本，++i返回的是对象本身。所以++i更加节省空间，提高性能。*i++，相当于*i;i+1。
70. sizeof运算符返回一条表达式或一个类型名字所占的字节数，返回值是size_t类型的常量表达式。sizeof并不实际计算其运算对象的值。对数组执行sizeof运算得到整个数组所占空间大小。
71. 逗号运算符。首先对左侧的表达式求值，然后将求值结果丢弃。逗号运算符真正的结果是右侧运算符的值。
72. 隐式转换。数组转换成指针。除了用于decltype，取地址符&，sizeof，typeid时仍然是对象。指针转换：常量整数值0或者字面值nullptr可以转成任意指针类型，指向任意非常量的指针能转换成void*，指向任意对象的指针能转换const void*。
73. 命名的强制转换。
    1. const_cat
    2. static_cast
    3. dynamic_cast
    4. reinterpret_cast

旧式强制类型转换

    1. type (expr)//函数形式
    2. (type) expr//c语言风格
74. 表达式加分号变成表达式语句，作用是执行表达式并丢掉求值结果。空语句(;)，空块({})。控制语句中声明的变量属于块内可见，且必须初始化。for语句定义的对象只在for循环体内可见。
75. 悬垂else问题，if对于else，else和谁匹配?else和最近的if匹配。使用花括号控制执行路径。
76. switch...case结构。switch后的表达式转换成整数类型(int/char)，然后和case标签的值做比较。case标签(case和值)必须是整数常量表达式。case标签的值不能相同。default标签，默认情况，最少加上空语句或者空块。
77. switch内部如果有变量定义，不允许跨过变量的初始化语句直接跳到该变量作用域内的另一个位置。所以变量应该定义在块内。
78. 当不清楚到底要迭代多少次，或者想在循环后访问循环控制变量时使用while循环。while的循环控制变量可以定义在while外面或者条件部分。do...while的循环控制变量只能定义在do外面。
79. 跳转语句：
    1. break
    2. continue
    3. goto
    4. return
80. 异常处理，当程序的某部分检测单一个它无法处理的问题时，需要异常处理。异常处理机制为程序中的异常检测和异常处理提供支持。
    1. throw表达式，异常检测，引发异常
    2. try语句块，包括catch子句(异常处理代码)
    3. 一套异常类
81. 在真实的程序中，应该把对象操作的代码和用户交互的代码分离开。所以使用try...catch捕获异常，和用户进行交互。如果最终没有找到匹配的catch语句，程序转到terminate库函数，一般情况下将导致程序非正常退出。没有定义try语句块的异常也是这处理。
82. 在异常发生期间正确执行了“处理”工作的程序被称为异常安全的代码。
83. 函数是一个命名了的代码块，我们可以通过调用函数来执行相应的代码。
84. 函数调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权从调用函数转移给被调用函数。此时主调函数的执行被暂时中断，被调函数开始执行。return语句也完成两项工作：一是返回return语句的值用来初始化调用表达式的结果，二是将控制权从被调函数转回主调函数。
85. 因为函数调用固定是实参和形参数量一致，所以形参一定会被初始化。实参必须能转换成形参。形参间不能同名，函数最外层作用域中的局部变量也不能使用和形参相同的名字。形参和函数体内定义的变量统称局部变量。
86. 函数返回值不能说数组或者函数类型，但是可以说指向数组或函数的指针。
87. 名字有作用域，对象有生命周期。
    1. 名字的作用域是程序文本的一部分，名字在其中可见。
    2. 对象的生命周期是程序在执行过程中该对象存在的一段时间。
88. 函数声明(函数原型)，在头文件中进行函数声明。在头文件声明变量。
89. 需要修改实参的值时，传引用；不需要改变实参的值时，传常量引用。一个函数只能返回一个值，当我们需要同时返回多个值时，可以给函数传入一个额外的引用形参保存另一个值。
90. const形参和实参
    1. 用实参初始化时也会忽略形参的顶层const。当形参有顶层const时，传给它常量或非常量对象都可以。f(int)和f(const int)可以传int，const int。
    2. 形参是非常量引用时，不能传常量或者字面值。f(int&)可以传int
    3. 形参是常量引用时，可以传字面值。f(const int&)可以传int，const int，50字面值
    4. 如果不修改实参，尽量使用常量引用，因为可以接受更多的实参类型。
91. 数组形参。数组有两个特殊性质：一是不能拷贝数组，二是数组名相当于指针。所以不能值传递，只能引用或者指针传递。f(int*a)和f(int a[])是一样的，数组的大小对函数的调用没有影响。因为不知道数组大小，所以需要管理指针数组（提供数组大小信息）：
    1. 使用标记指定数组长度，比如c风格字符串以空字符结束
    2. 使用标准库规范，传递指向数组首元素和尾元素的指针
    3. 显式传递一个表示数组长度的形参

形参可以是数组的引用。f(int (&a)[10])，这样只能给f传进有十个元素的数组。

传递二维数组。f(int (*a)[10]),或者f(int a[][10]),第一维度会被忽略，第二维度需要明确说明。

92. 命令行参数。int main(int argc,int *argv[])第一个参数argc是argv数组元素个数，第二个参数argv是指针数组，元素是指向c风格字符串的指针。数组第一个元素是文件名或者空串，后面的是命令行参数。最后一个指针之后的元素是0。
93. 返回类型。值返回，返回的是临时对象，或者拷贝。引用和指针返回的是原对象。除了局部对象必须值返回，其他都尽可能引用返回和指针返回。引用返回左值，返回非常量引用时可以再次赋值，其他都返回右值。可以使用列表(花括号包围的值)初始化返回值。main函数可以不写return语句，因为会隐式插入return 0;
94. 返回数组的指针或者引用。
    1. 类型别名typedef int a[10];//using a =int[10];

a* f(int i);

    2. 声明一个返回数组指针的函数int (*f(int))[10];
    3. 使用后置返回类型auto f(int i)->int(*)[10];
95. 函数重载，同名函数，看形参类型和数量，不看返回值类型。形参中，顶层const可以忽略，底层const不能忽略。函数匹配，重载确定，把函数调用和重载函数中的一个对应上。调用重载函数有三种情况：
    1. 找到一个最佳匹配，正确
    2. 没有找到匹配的，出错，无匹配
    3. 有多个可以匹配，没有最佳匹配，出错，二义性调用
96. 在内层作用域声明重载函数，会隐藏外层的重载函数。当内层作用域找到函数时，发现类型不同，返回错误，即使外层有匹配的重载函数。因为c++先进行名字查找，然后才进行类型匹配。所以重载函数声明应该放在同一个作用域。
97. inline内联函数在调用点内联地展开。constexpr函数，指用于常量表达式的函数，返回值和形参类型需要是字面值类型，并且函数有且只有一条return语句，隐式的内联函数。constexpr函数不一定返回常量表达式。这两个函数可以放在头文件定义。
98. assert预处理宏，其实是一个预处理变量，行为类似内联函数。assert(i>0);首先对表达式求值，如果表达式为0，assert输出信息并终止程序的执行。如果表达式为非0，assert什么也不做。assert的行为依赖与一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG（#define NDEBUG，或者-D NDEBUF），关闭调试状态，assert什么也不做。默认没有定义NEDEBUG。五个宏定义：
    1. __FILE__文件名
    2. __LINE__当前行号
    3. __TIME__编译时间
    4. __DATA__编译日期
    5. __func__函数名字
99. 函数匹配：确定应该调用哪个重载函数。
    1. 选定本次调用对应的重载函数集，集合中的函数称为候选函数。具备的特征：一是和被调用的函数同名，二是其声明在调用点可见。
    2. 根据实参选出可行函数。具备的特征：一是形参数量和实参数量相等，二是实参类型和形参类型相同，或者可以转换成形参类型。如果没找到，报告无匹配错误。
    3. 寻找最佳匹配，逐一检查函数调用提供的实参，寻找形参类型和实参类型最匹配的可行函数。如果有且只有一个函数满足下列条件，匹配成功：
        1. 该函数每个实参的匹配都不劣于其他可行函数需要的匹配
        2. 至少有一个实参的匹配优于其他可行函数提供的匹配。
    4. 如果没有一个可行函数脱颖而出，那么报告二义性调用错误。

调用重载函数应该尽量避免强制类型转换。

100. 实参类型转换，用于确定最佳匹配。
    1. 精确匹配。一是实参类型和形参相同，二是实参从数组类型或函数类型转换成对应的指针类型，三是向实参添加订餐const或从实参中删除顶层const
    2. 通过const转换实现的匹配
    3. 通过类型提升实现的匹配
    4. 通过算术类型转换或指针转换实现的匹配
    5. 通过类类型转换实现的匹配
101. 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是用户只能使用接口而无法访问实现部分。类的接口包括成员函数和类相关的普通函数。
102. this指针，指针常量，指针本身不能改变。成员函数通过this作为隐式参数访问调用的对象。对象的地址就是this的值。传给任何对类成员的直接访问都被看做this的隐式引用。返回对象本身用return *this;返回值类型为A&，返回对象的引用，返回的是左值。
103. 可以用int去初始化const int。但是不能用const int去初始化int。函数形参匹配利用到这个。常函数也用到这个。一般变量初始化也用到。
104. 常量成员函数，int f()const;const修饰的是this指针。默认情况下this类型是A * const。但是我们不能把绑定到常量对象上，这时需要把this定义成const A * const。通过在参数列表后面加const实现常函数。常函数不能改变对象的数据成员。常量对象以及常量对象的引用或指针只能调用常函数。
105. f(const) 说明形参不修改实参。f()const 说明不修改类数据成员。const f()说明返回值是常量。
106. 构造函数，如果需要使用默认构造函数可以使用a()=default;要求编译器生成构造函数。构造函数初始化列表。构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值和原值不同。

初始化列表和类内初始化和构造函数体内赋值。

    1. 初始化列表，第一优先级。顺序是严格的。一般给数据成员初始化。
    2. 类内初始化，第二优先级。多个构造函数，类内初始化只写一次。顺序是隐式的。不可以(),只能=或者{}。给静态成员初始化。
    3. 构造函数体内赋值，第三优先级，尽量别用，因为类内初始化会使用默认初始化

如果成员是const，引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始化列表进行初始化。

成员的初始化顺序和它们在类定义中出现的顺序一致。最好令构造函数初始化的顺序和成员声明一致。

107. 除了第一类的对象的初始化，类还需要控制拷贝，赋值和销毁对象时发生的行为。构造函数，拷贝构造函数，拷贝赋值函数，析构函数这些函数编译器都有默认函数。当类需要分配类对象之外的资源时，默认版本常常失效。
108. mutable修饰的可变数据成员，永远不会是const的，即使他是const对象的成员。任何成员函数都能修改该值，即使是在const成员函数内。
109. 编译器处理完类中的全部声明后才会处理成员函数的定义。所以函数体能使用类中定义的任何名字。
110. 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。
111. 委托构造函数，一个委托构造函数使用它所属类的其他构造函数执行它的初始化。
112. 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数也称转换构造函数。单参数构造函数实际上定义了从参数类型转换成类类型的隐式转换规则。但是只允许一步类型转换。使用explicit阻止构造函数的隐式转换。这时构造函数只能用于直接初始化。
113. 聚合类，使得用户可以直接访问成员，并且具有特殊的初始化语法。条件：
    1. 所有成员都是public
    2. 没有定义构造函数
    3. 没有类内初始值
    4. 没有基类，没有虚函数

struct Data {

int ival;

string s;

};

使用成员初始化列表来初始化。Data val ={0,"a"}

114. 当类需要它的一些成员与类本身直接有关，而不是与类的各个对象保持关联时，使用类的静态成员。所有类的对象共享同一个静态数据成员，静态成员函数没有this指针，不能被声明为const 只能使用静态数据成员。它们不是由类的构造函数初始化的，必须在类的外部定义和初始化静态成员。
115. 类内的数据成员，不能声明为当前类类型，因为当前类类型大小未知，只能声明为当前类的指针或引用。但是静态数据成员的类型可以是当前类类型。并且可以使用静态成员作为默认实参，非静态成员不能作为默认实参。
116. io对象无拷贝和赋值。进行io操作的函数一般以引用方式传递和返回流。读写一个io对象会改变其状态，因此传递和引用的对象不能为const。确定一个流对象的状态最简单的方法是作为条件使用。while(cin>>word)。如果输入操作成功，流保持有效状态，则条件为真。
117. 适配器，容器、迭代器和仿函数都有适配器。本质上适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。
118. 标准库并未给每个容器都定义成员函数来实现操作，而是定义了一组泛型算法：称它们为算法，是因为它们实现了一些经典算法的公共接口，称它们是泛型的，是因为它们可以用于不同类型的元素和多种容器类型。泛型算法本身不会执行容器的操作，他们只会运行在迭代器之上，执行迭代器的操作。算法永远不会改变底层容器的大小。算法只能通过插入器（特殊的迭代器）完成添加元素的操作。
119. 插入迭代器是一种向容器中添加元素的迭代器。一般我们通过迭代器向容器元素赋值时，值被赋予迭代器指向的元素，而通过插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加进容器。
120. 谓词，是一个可调用的表达式，其返回值是一个能作为条件的值。谓词分一元谓词和二元谓词。谓词可以是一个函数，也可以是仿函数，还可以是lambda表达式。我们可以向一个算法传递任何类别的可调用对象（一个对象或者表达式，如果可以对其使用调用运算符则称之为可调用的）
121. 一个lambda表达式表示一个可调用的代码单元，可以理解成一个未命名的内联函数。捕获列表和函数体是必须的。lambda不能有默认参数。

值捕获[=],[a],引用捕获[&],[&a]

可变lambda，默认情况下值捕获的变量，lambda不会改变其值，若想改变则在参数列表后加mutable

如果一个lambda体包含return外的任何语句，则编译器假定此lambda返回void。需要为lambda定义返回类型，使用后置返回类型。

122. 如果需要一个一元谓词，却只有二元谓词，可以使用bind函数绑定参数。bind函数是一个函数适配器。比如a(string,int)变成auto f =bind(a,_1,10)这就是把a的第二参数固定成10。f接受一个参数，这个参数就是a的第一参数。所以f("n")就是在调用a("n",10)

可以用bind绑定给定可调用对象中的参数(a=bind(f,A,_1,B,_2),使用a(X,Y)相当于f(A,X,B,Y))或重新安排其顺序(a(A,B)变成bind(a,_2,_1))

可以绑定引用参数，当绑定参数无法赋值，或者希望引用传递时使用。ref(os)，返回一个对象，包含对os的引用，此对象是可以拷贝的。cref则可以生成一个保存const引用的类。

123. 内存管理
    1. 静态内存：用来保存局部static对象、类static数据成员、定义在任何函数之外的变量。也就是全局变量和静态变量
    2. 栈内存：用来保存定义在函数内的非static对象。也就是局部变量
    3. 动态内存：自由空间或堆，内存池。用堆存储动态分配的对象。new和delete，需要手动delete。为了更安全地使用动态内存，引入智能指针，析构函数自动delete。
        1. shared_ptr，允许多个指针指向同一个对象
        2. unique_ptr，独占所指向地对象
        3. weak_ptr，弱引用，指向shared_ptr所管理的对象。
124. 智能指针使用方式和指针类似，默认初始化的智能指针中保存一个空指针。最安全的分配和使用动态内存的方法是调用make_shared()，在动态内存中分配一个对象并初始化。auto p=make_shared<vector<string>>();当进行拷贝(值传递或者返回值)或者赋值时，每个shared_ptr都会使用引用计数来记录有多少个其他的shared_ptr指向同一个对象。当一个shared_ptr的计数器变成0，它会自动释放自己管理的对象。
125. 程序使用动态内存的原因：
    1. 程序不知道自己需要使用多少对象
    2. 程序不知道所需对象的准确类型
    3. 程序需要在多个对象间共享数据
126. 在自由空间分配到内存是无名的，所以new无法为其分配到对象命名，只能返回一个指向该对象的指针。int * p=new int，*p的值未定义。动态分配到对象是默认初始化的，意味着内置类型hr组合类型到对象将是未定义的，类类型对象将用默认构造函数进行初始化。可以直接初始化，int*p=new int(10)，*p为10；也可以值初始化，int*p=new int()，*p为0。new失败时，表明没有可分配内存，抛出bad_alloc异常。使用定位new可以向new传递额外的参数，如果想不抛出异常可以int*p=new(nothrow) int;分配失败返回空指针。delete p后，p所指向地动态内存已经释放，但是p指针值就变得无效了，却仍然保存着动态内存的地址，这时p变成空悬指针。所以一般需要给p置空，p=nullptr;但是如果有多个指针指向同一个内存，释放内存时，很难把所有指针都置空。所以需要sharded_ptr和new结合使用。shared_ptr<int> p(new int (1024))。不能使用shared_ptr<int> p = new int (1024)，因为接受指针参数的智能指针构造函数是explicit，不能隐式转换。

不要混合使用普通指针和智能指针。也不要使用get初始化另一个智能指针或为智能指针赋值。智能指针定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象。还可以用reset来将一个新的指针赋予一个shared_ptr，p.reset(new int(1024))

127. 一个简单的确保资源被释放的方法是使用智能指针。因为在发生一异常时，智能指针会自动释放内存，而new分配到内存可能还没有执行delete就结束了。
128. 默认情况下，shared_ptr指向的是动态内存。当一个shared_ptr被销毁时，它默认地对它管理的指针进行delete操作。如果我们使用类似的技术管理不具备良好定义的析构函数的类connection，就需要使用一个函数代替delete，保证connection被正确关闭。这就是删除器函数。删除器必须能够完成对shared_ptr中保存的指针进行释放操作。
129. 智能指针的基本规范：
    1. 不使用相同的内置指针初始化（或reset）多个智能指针
    2. 不delete get()返回的指针
    3. 不使用get返回的指针初始化或reset另一个智能指针
    4. 如果你使用get返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变无效了
    5. 如果你使用智能指针管理的资源不是new分配到内存，记住传递它一个删除器。
130. unique_ptr拥有它所指向地对象，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向地对象也被销毁。我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针。初始化unique_ptr必须采用直接初始化的方法。unique_ptr不支持普通的拷贝或赋值操作。但是可以通过release或reset将指针的所有权从一个非const unique_ptr转移给另一个unique_ptr。release成员返回unique_ptr当前保存的指针并将其置空。reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不为空，则它原来指向的对象被释放，然后接管新的对象。新的对象需要先release。使用release会切断unique_ptr和它原来管理的对象间的联系。release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。我们可以拷贝或赋值一个将要被销毁的unique_ptr。
131. weak_ptr，是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会增加其引用计数。一旦指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向该对象，仍然会被释放。需要使用shared_ptr初始化weak_ptr。不能直接访问对象，而应该调用lock来检查weak_ptr指向的对象是否仍然存在。如果存在，lock返回一个指向共享对象的shared_ptr。
132. 动态数组，使用new[]可以分配并初始化一个对象数组，返回指向第一个对象的指针。标准库中有一个allocator类可以使分配和初始化分离。大多数应用应该使用vector而不是new[]。allocator提供一种类型感知的内存分配方法，它分配到内存是原始的、未构造的。使用construct成员函数构造对象，其接受一个指针和零个或多个额外参数（用来初始化构造的对象）destroy函数接受一个指针，对指向的对象进行析构函数。释放内存使用deallocate函数。
133. 一个类通过定义五种特殊的成员函数来控制对象的拷贝，移动，赋值和销毁。拷贝控制操作
    1. 拷贝构造函数
    2. 拷贝赋值运算符
    3. 移动构造函数
    4. 移动赋值运算符
    5. 析构函数
134. 拷贝构造函数，构造函数的第一个参数是自身类类型的引用，一般是const，且任何额外参数都有默认值。不应该是explicit的。默认拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。第一个参数需要是引用类型，因为如果是非引用类型，拷贝构造函数将继续调用拷贝构造函数，一直循环。
135. 直接初始化和拷贝初始化的区别：直接初始化时是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；拷贝初始化时是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话，还要进行类型转换。发生拷贝初始的情况：
    1. 用=定义变量
    2. 将一个对象作为实参传递给一个非引用类型的实参
    3. 从一个返回类型为非引用类型的函数返回一个对象
    4. 用花括号初始化一个数组中的元素或一个聚合类的成员
136. 




