#### 1、在main执行之前和之后执行的代码可能是什么？

main()前：

- 设置栈指针
- 初始化静态和全局变量
- 将未初始化的静态和全局变量赋初值
- 全局对象初始化
- 将命令行参数传递给main()
- `__attributu__((constructor))`

main()后：

- 全局对象析构
- atexit()注册的函数
- `__attribute__((destructor))`

#### 2、结构体内存对齐问题？

- 结构体成员按声明顺序存储
- 结构体与最大成员对齐
- `#pragma pack(4)` 

#### 3、指针和引用的区别

- 指针是一个变量，有自己的地址空间；引用是原变量的别名
- 指针可以不初始化；引用必须初始化
- 指针可以为空；引用不能为NULL
- 指针初始化后可以改变指向；引用初始化不能改变指向
- 指针可以有多级；引用只有一级
- 指针sizeof得到指针大小；引用sizeof得到原变量大小

#### 4、堆和栈的区别

- 申请方式不同。堆通过new来手动申请；栈是由系统自动分配的
- 申请大小不同。堆大小灵活，一般4G（虚拟内存）；栈一般2M大小
- 扩展方向不同。堆向高地址扩展；栈从高地址向低地址扩展
- 申请效率不同。堆申请速度慢（函数库实现），会有碎片；栈速度快（系统通过的数据结构，专门寄存器），不会有碎片
- 分配方式不同。堆只有动态分配的；栈可以静态分配也可以由allocal()动态分配

#### 6、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间

虚函数表的特征：

- 虚函数吧是全局共享的，仅有一个，编译时就构造完成
- 虚函数表类似数组，类对象中有vptr指针指向虚函数表，它不是函数，不在代码段
- 虚函数表存储了虚函数的地址，虚函数个数在编译时可以确定，因此虚函数表大小确定，不必通过堆动态分配内存

因此虚函数表类似静态变量。实际上C++中虚函数表位于只读数据段（.rodata）；而虚函数则位于代码段（.text）。

在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。

由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。

#### 7、new / delete 与 malloc / free的异同

相同点

- 都可用于内存的动态申请和释放

不同点

- new是C++运算符，malloc是标准库函数
- new自动计算空间大小，malloc需要手动计算
- new是类型安全的，malloc不是（int *p = new float[2]; 会编译错误）
- new返回的是对象指针，malloc返回void*指针
- new会调用对象的构造函数
- malloc需要库文件支持（#include<memory>）

#### 8、new和delete是如何实现的？

```c++
Complex* pc = new Complex(1,2);

//被编译器转换成
Complex* pc;
//operator new 内部调用malloc(n)
void* mem = operator new(sizeof(Complex));//分配内存
pc = static_cast<Complex*>(mem);//转型void*转Complex*
pc->Complex::Complex(1,2);//构造函数
//Complex::Complex(pc,1,2);谁调用成员函数，谁就是this

delete pc;
// 编译器转为
pc->~Complex();//析构，可以直接调用
operator delete(pc);//释放内存，内部调用free()
```

#### 10、宏定义函数和函数有何区别？

- 宏在预编译时完成替换；函数在运行时调整到调用函数
- 宏函数没有返回值；函数有返回值
- 宏函数参数没有类型，不需要类型检查；函数参数有类型，需要类型检查
- 宏函数不要在最后加分号

#### 11、宏定义和typedef区别？

- 宏定义用于定义常量和书写复杂的内容；typedef用于定义类型别名
- 宏在预编译时完成替换；typedef是编译的一部分
- 宏不检查类型；typedef会检查数据类型
- 宏不是语句，不用在最后加分号；typedef是语句，要加分号标识结束。
- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

#### 12、变量声明和定义区别？

- 声明不分配内存；定义需要分配内存
- 声明可以多次；定义只能一次

#### 13、哪几种情况必须用到初始化成员列表？

- 初始化一个const成员
- 初始化一个reference成员
- 调用一个基类的构造函数，该函数有一组参数
- 调用一个数据成员对象的构造函数，而该函数有一组参数

后两点的原理是因为如果不用初始化成员列表，则在构造函数体内赋值。那么会先调用默认构造函数，再调用赋值构造函数。所以如果函数有一组参数，说明没有默认构造函数，则编译出错。

#### 14、strlen和sizeof区别？

- sizeof 是运算符；strlen是函数
- sizeof在编译时获得结果；strlen在运行时获得结果(调用函数)
- sizeof参数可以是任何数据或者数据类型；strlen只能用于C风格字符串
- sizeof不能用来得到动态分配（运行时分配）存储空间的大小

#### 16、数组a和&a有什么区别？

int a[4];

a是指向a[0]的指针，类型是int*，存储的是首元素a[0]的地址即a==&a[0]，a+1指向a[1]

&a是指向整个数组的指针，类型是int(*p)[4]，&a+1指向a[4]

#### 17、数组名和指针区别？

int a[4], *p=&a;

- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

#### 18、野指针和悬空指针

都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。

- 野指针，指的是没有被初始化过的指针
  -  定义指针变量及时初始化，要么置空。
- 悬空指针，指针最初指向的内存已经被释放了的一种指针
  -  释放操作后立即置空，引入智能指针

#### 19、迭代器失效的情况

vector

- 尾后插入，首迭代器不失效尾迭代失效，扩容时所有迭代器失效
- 中间插入，首迭代器不失效但插入元素之后所有迭代器失效，扩容时所有迭代器失效
- 尾后删除：只有尾迭代失效。
- 中间删除：删除位置之后所有迭代失效。

deque和vector类似

list 删除节点仅当前迭代器失效

map/set 删除节点不影响其他节点的迭代器

unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效.

#### 20、C和C++的区别

- C++可以重载，因为有名字修饰
- C++有引用，C没有
- C++有异常处理机制，C只是错误码
- C++是面向对象的（数据和方法结合成类），C是面向过程的（数据和方法分开）

#### 21、C++与Java的区别

**语言特性**

- Java没有指针，引入了真正的数组
- Java编写一次，多处运行
- Java完全面向对象，有JVM，移植性强
- Java用接口取代多继承

**垃圾回收**

- Java有垃圾回收机制，C++通过智能指针，RAII机制管理内存

**应用场景**

- Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 
- Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架
- 对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在

#### 22、C++和C的struct区别

- C++结构有访问权限
- C++结构可以继承
- C++结构可以定义函数
- C++结构可以隐藏数据
- C++结构使用可以直接使用不带struct。

#### 23、define宏定义和const的区别

- 宏发生在预处理阶段；const是在编译时，会发生常量折叠
- 宏不检查类型；const检查数据类型
- 宏定义的数据没有分配内存空间，存储在代码段；const常量分配内存，存储在数据段
- 宏定义是全局的，const常量是局部的
- 宏定义不能做函数参数
- 宏定义不能调试
- 宏定义可以重新定义，const常量不能重新定义

#### 24、C++中const和static的作用

static

- 不考虑类的情况
  - 隐藏，只有当前文件可见
  - 持久性，静态存储区，生命周期长
  - 默认初始化为0
- 考虑类的情况
  - 成员变量，只和类关联，定义时分配空间，需要在类外初始化。
  - 成员函数，不具有this指针，只能访问静态函数和静态变量，不能被声明为const、virtual、volatile

const

- 不考虑类的情况
  - const常量在定义时必须初始化，之后无法更改
  - const形参可以接收const和非const类型的实参
- 考虑类的情况
  - 成员变量，只能通过初始化列表初始化
  - 成员函数，const对象只能调用const函数，不可以改变非mutable成员变量

#### 27、final和override关键字

override是用于子类的虚函数上，告诉编译器这函数需要重写。

final是用于基类的虚函数上，告诉编译器这函数不能被重写。

final也可以用于禁止类被继承。

#### 28、拷贝初始化和直接初始化

```c++
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始化
string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
```

**为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了**（语句1和语句3等价），但是需要辨别两种情况。

- 当拷贝构造函数为private时：语句3和语句4在编译时会报错
- 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

#### 29、初始化和赋值的区别

- 对于简单类型来说，初始化和赋值没什么区别
- 对于类和复杂数据类型来说，这两者的区别就大了。
  - 初始化使用的是拷贝构造函数
  - 赋值使用的是赋值运算符函数，

#### 30、extern"C"的用法

为了能够**正确的在C++代码中调用C语言**的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；

实际上是告诉编译器，这函数不需要名字修饰。

总结出如下形式：

（1）C++调用C函数：

```c
//xx.h
extern int add(...)

//xx.c
int add(){
    
}

//xx.cpp
extern "C" {
    #include "xx.h"
}
```

（2）C调用C++函数

```c
//xx.h
extern "C"{
    int add();
}
//xx.cpp
int add(){
    
}
//xx.c
extern int add();
```

#### 31、模板函数和模板类的特例化

**模板函数特例化**

必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参

**类模板特例化**

在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template<>表示是一个特例化版本

**类模板的部分特例化**

不必为所有模板参数提供实参，可以**指定一部分而非所有模板参数**，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参

#### 32、C和C++的类型安全

**C的类型安全**

C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。

- printf格式输出会报错。`printf("%f\n",10);`
- malloc函数返回值使用显式类型转换不会报错。`int* pInt=(int*)malloc(100*sizeof(char));`

**C++的类型安全**

- 操作符new返回的指针类型严格与对象匹配，而不是void*
- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
- 引入const关键字代替#define常量，它是有类型、有作用域的，而#define constants只是简单的文本替换
- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全
- C++提供了**dynamic_cast**关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

#### 33、为什么析构函数一般写成虚函数

由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。

所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。

但存在一种特例，在`CRTP`模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应 该声明为虚函数，因为这种继承方式，不需要虚函数表。