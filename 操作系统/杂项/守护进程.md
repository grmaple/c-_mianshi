## 守护进程

https://blog.csdn.net/mijichui2153/article/details/81394387

我们可以认为守护进程就是后台服务进程，因为它会有一个很长的生命周期提供服务，关闭终端不会影响服务，也就是说可以忽略某些信号。

守护进程是后台运行的、系统启动是就存在的、不予任何终端关联的，用于处理一些系统级别任务的特殊进程。

### 下面介绍一下创建守护进程的步骤

1、fork()创建子进程，父进程exit()退出；

​	//在形式上做到了与控制终端的脱离，在后台工作

2、在子进程调用setsid()创建新会话；

​	//使进程完全独立出来

3、再次 fork() 一个子进程，父进程exit退出；

​	//使进程不再是会话首进程来禁止进程重新打开控制终端。

4、在子进程中调用chdir()让根目录“/”成为子进程的工作目录；

​	//避免原父进程当前目录带来的一些麻烦

5、在子进程中调用umask()重设文件权限掩码为0；

​	//相当于把权限开发

6、在子进程中close()不需要的文件描述符；

​	//关闭失去价值的输入、输出、报错等对应的文件描述符

7、守护进程退出处理。

​	//实现 kill 发出的signal信号处理，达到进程的正常退出。



### 1、fork()创建子进程，父进程exit()退出；

这是创建守护进程的第一步。由于守护进程是脱离控制终端的，完成这一步后就会在Shell终端里造成程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。

由于父进程先于子进程退出，子进程就变为孤儿进程，并由 init 进程作为其父进程收养。

### 2、在子进程调用setsid()创建新会话；

在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变。这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来。

 setsid()创建一个新会话，调用进程担任新会话的首进程，其作用有：

- 使当前进程脱离原会话的控制
- 使当前进程脱离原进程组的控制
- 使当前进程脱离原控制终端的控制

这样，当前进程才能实现真正意义上完全独立出来，摆脱其他进程的控制。

### **3、再次 fork() 一个子进程，父进程exit退出；**

现在，进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端，可以通过 fork() 一个子进程，该子进程不是会话首进程，该进程将不能重新打开控制终端。退出父进程。

也就是说通过再次创建子进程结束当前进程，使进程不再是**会话首进程**来禁止进程重新打开控制终端。

### 4、在子进程中调用chdir()让根目录“/”成为子进程的工作目录；

这一步也是必要的步骤。使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“/mnt/usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入单用户模式）。因此，通常的做法是让"/"作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变工作目录的常见函数是chdir。(避免原父进程当前目录带来的一些麻烦)

### 5、在子进程中调用umask()重设文件权限掩码为0；

文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限（就是说可读可执行权限均变为7）。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此把文件权限掩码重设为0即清除掩码（权限为777），这样可以大大增强该守护进程的灵活性。通常的使用方法为umask(0)。(相当于把权限开发)

### 6、在子进程中close()不需要的文件描述符；

同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。其实在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）已经失去了存在的价值，也应被关闭。（关闭失去价值的输入、输出、报错等对应的文件描述符）

### 7、守护进程退出处理

当用户需要外部停止守护进程运行时，往往会使用 kill 命令停止该守护进程。所以，守护进程中需要编码来实现 kill 发出的signal信号处理，达到进程的正常退出。

![img](https://i.loli.net/2020/10/26/IPeMi12wm5b4sZp.jpg)

```cpp
#include<stdio.h>
#include<fcntl.h>
#include<sys/stat.h>
#include<string.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
 
int main(){
    pid_t pid;
    char buf[]="this is a dameon\n";
    pid=fork();//创建一个进程用来做守护进程
    if(pid>0){ //父进程退出，此时 子进程变为孤儿进程。
        exit(0);
    }
    setsid();   //使子进程独立1.摆脱原会话控制 2.摆脱原进程组的控制 3.摆脱控制终端的控制
    chdir("/"); //改变当前工作目录，这也是为了摆脱父进程的影响
    umask(0);   //重设文件权限掩码
    int i;
    for(i=0;i<1024;i++){    //关闭文件描述符(常说的输入，输出，报错3个文件)，
        close(i);            //因为守护进程要失去了对所属的控制终端的联系，这三个文件要关闭
    }
 
    int fd=open("dameon.txt",O_CREAT|O_WRONLY|O_APPEND,0777);
    if(fd<0){
        perror("open");
        return -1;
    }
    while(1){
        write(fd,buf,strlen(buf)+1);
		printf("This is a deamon!!\n");
        sleep(5);
    }
 
    close(fd);
}
```

