## 堆栈和内存结构

### 栈

https://www.jianshu.com/p/52b5a1879aa1

栈由系统管理。但是为什么呢？

首先，栈是一个**后进先出(LIFO)**结构。当把数据放入栈时，我们把数据push进入；当从栈取出数据时，我们把数据pop出来。栈随着数据被压入或者弹出而增长或者减小。最新压入栈的项被认为是在“栈的顶部”。当从栈中弹出一个项时，我们得到的是位于栈最顶部的那一个。就像给弹夹上子弹，只能在顶部进行操作。

在x86体系中，栈顶由**堆栈指针寄存器ESP**来标记，它是一个32位寄存器，里面存放着最后一个压入栈顶的项的内存地址。正因为有它，我们才能够随时操作到需要的项。需要注意的是，**栈顶是朝着地内存方向增长的。**

栈应该被看成一个短期存储数据的地方，存在在栈中的数据项没有名字，只是按照后进先出来操作罢了。栈经常可以用来在寄存器紧张的情况下，临时存储一些数据，并且十分安全。当寄存器空闲后，我们可以从栈中弹出该数据，供寄存器使用。**这种临时存放数据的特性，使得它经常用来存储局部变量，函数参数，上下文环境等。**

C语言中的函数，对应汇编中的过程。一个过程调用包括将数据(以过程参数和返回值的形式)和控制从代码的一部分传递到另一部分。另外，**它还必须在进入时为过程的局部变量分配空间，并在退出时释放这些空间。**上述的数据传递，局部变量的分配和释放通过操纵程序帧来实现。

程序用程序栈来支持过程调用。机器用栈来传递过程参数，存储返回信息，保存寄存器用于以后恢复，以及本地存储。**为单个过程分配的那部分成为栈帧(stack frame)。**下图描绘了栈帧的通用结构，最顶端的栈帧以两个指针界定，寄存器**%ebp为帧指针**，而寄存器**%esp为栈指针**。

**当程序执行时，栈指针可以移动，因此大多数信息访问都是相对于帧指针的。**(注：**%esp**与**ESP**是同一个寄存器的不同说法而已，**%ebp**同理)

<img src="https://upload-images.jianshu.io/upload_images/1609713-7aeccbd50995ca02.jpg" alt="img" style="zoom: 20%;" />

假设过程**P(调用者)**调用过程**Q(被调用者)**，则Q的参数放在P的栈帧中。另外，**当P调用Q时，P中的返回地址被压入栈中，形成P的栈帧的末尾。返回地址就是当P从Q返回时应该继续执行的地方。**Q的栈帧从保存的帧指针的值(例如寄存器%ebp的副本)开始，后面时保存的其他寄存器的值。

过程Q也用栈来保存其他不能存放在寄存器中的局部变量，这样做的原因如下：

- 没有足够的寄存器存放所有的局部变量。和前文汇编语言部分解释的原因相同。
- 有些局部变量是数组或者结构，因此必须通过数组或者结构引用来访问。
- 要对一个局部变量使用地址操作符'&'，我们必须能够为它生成一个地址。

另外，Q也会用栈帧来存放它调用的其它过程的参数。**参数n位于相对于%ebp偏移量为4+4n字节的地方。**较大的参数(如结构体和较大的数字格式)需要栈上更大的区域。

正如前文所讲，栈向低地址方向增长。栈指针%esp指向栈顶元素，可以用push存入数据，用pop取出数据。将栈指针的值减小适当的大小可以分配没有指定初始值的数据的空间(加入数据栈顶向低地址方向移动)。类似地，可以通过增加栈指针来释放空间(取出数据栈顶向高地址方向移动)。

### 堆

**.bss段**和**栈**之间有一段空余内存，C程序经常使用这种剩余内存空间来为那些为于堆内存中的，**“已经在运行中”**的变量分配空间。我们常说的堆就存在于这里。

相反，堆相对于栈，更加强调需要进行控制。常见的就是我们手动申请，手动释放。因此可以分配更大的空间，但开销也会更多。

是不连续的内存区域。

分配器将堆视为一组不同大小的块(block)的集合来维护。每一个块就是一个连续的虚拟存储片(chunk)，要么已分配，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲的块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配的状态，知道它被释放。这种释放要么是应用程序显式执行的，要么是存储器分配起自身隐式执行的。

- **显式分配器(explicit allocator)**，要求应用显式地释放任何已分配的块。如C中的malloc和free。C++中的new和delete。
- **隐式分配器(implicit allocator)**，要求分配器检测一个已分配的块何时不再被程序所使用，就去释放这个块。隐式分配器也叫做垃圾收集器(garbage collector)，而自动释放未使用的且已被分配的块的过程叫做垃圾收集(garbage collection)。不用我说，你们也可能已经想到了Java的垃圾回收机制。

对于堆的组织方式，其中的一种方式：我们可以将堆组织为一个连续的已分配块和空闲块的序列，我们称这种结构为隐式空闲链表。空闲块通过头部中的大小字段隐含地连接着，分配器可以通过遍历堆中的所有块，从而间接遍历整个空闲块的集合

**堆和栈中的存储内容**   

栈：  在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。   

当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。  

 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。  

### 数据段

含有**static**关键词修饰的变量根据有无初始化，存储于**数据段**，即**data段**和**bss段**

局部变量并不进入可执行文件，它们在运行时创建，一般在栈上。

**bss段。**

未初始化数据段。不保存在硬盘上，只是记录数据所需空间的大小，程序开始执行之前，由内核进行初始化为0。

bss段不保存在目标文件中(除了记录bss段在运行时所需的大小)

**data段。**

初始化的字段，包含明确的初始化值，保存在硬盘上，由.exec读取

data段保存在目标文件中

### 代码段

　　**代码段/text段**通常是指用来存放程序执行代码的一块内存区域。

　　这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。

　　在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 

### 程序的内存分配

![img](https://upload-images.jianshu.io/upload_images/1609713-eaa6e0729938352f.jpg) 
 一个由C/C++编译的程序占用的内存分为以下几个部分 
 1、栈区（stack），由编译器自动分配释放  ，存放函数的参数值，局部变量的值等。其操作方式类似于[数据结构](http://lib.csdn.net/base/datastructure)中的栈。 
堆栈之间可能会有动态链接库。
 2、堆区（heap)， 一般由程序员分配释放，  若程序员不释放，程序结束时可能由OS回收  。一般存储new/malloc的数据。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 
 3、全局区（静态区）（static），全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域（data段），未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（bss段）。  -  程序结束后由系统释放。 
 4、文字常量区，常量字符串就是放在这里的。  程序结束后由系统释放 
 5、程序代码区，存放函数体的二进制代码。 

```CPP
#include <stdio.h>
int a = 0; //全局初始化区
char *p1; //全局未初始化区


int main()
{
    int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //123456\0在常量区，p3在栈上
    static int c =0; //全局（静态）初始化区
    p1 = (char *)malloc(10); //堆
    p2 = (char *)malloc(20);  //堆

    return 0;
}
```



### 不同类型的变量在内存中的位置

  	1、全局变量， 静态局部变量

- 已经初始化的全局变量/ 静态局部变量存放与data数据段；
- 未初始化的全局变量/ 静态局部变量存放与bss数据段。

  2、 静态的全局变量存放与data数据段

  3、 局部变量存放在栈上。

### **C程序中的存储空间布局：**

1.text段。存放文本指令的地方，保存在硬盘上，只读的，不可修改，由.exec程序读取。可共享，若一个程序有多个进程同时在运行，则可共享text段。

2.data段。初始化的字段，包含明确的初始化值，保存在硬盘上，由.exec读取

3.bss段。未初始化数据段。不保存在硬盘上，只是记录数据所需空间的大小，程序开始执行之前，由内核进行初始化为0。

4.堆。在动态内存中手动分配的。

5.栈。自动变量和函数调用时所需保存的信息都存放在此段中。



### Linux 运行时存储器映像

![img](https://upload-images.jianshu.io/upload_images/1609713-2bbad4b1b44b9b6d.jpg)

这张图涵盖了本文所讲的大多数知识点。相比于前文的那张汇编语言内存图，更加细分了。

- **代码段**总是从地址0x08048000处开始。
- **数据段**在接下来的下一个4KB对齐的地址处。
- 运行时**堆**在**读／写段(数据段)**之后接下来的第一个4KB对齐的地址处，并通过malloc库往上(高地址方向)增长。
- 中间还有一个段是为共享库(shared library)保留的。
- 用户**栈**总是从最大的合法用户地址开始，向下增长(低地址方向)
- 栈上方的段是为操作系统驻留存储器部分(也就是内核)的代码和数据保留的。
- 当程序开始运行时，加载器在可执行文件中段头部表的指引下，将可执行文件的相关内容拷贝到代码段和数据段。

### 线程共享栈吗?

线程占有的都是不共享的，其中包括：栈、寄存器、状态、程序计数器；

线程间共享的有：堆，全局变量.data区，静态变量.bss区和代码区text。

### C++的内存管理

在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。

代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

数据段：存储程序中已初始化的全局变量和静态变量

bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。

堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。

映射区:存储动态链接库以及调用mmap函数进行的文件映射

栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值

### C++/C的内存分配

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552467921124_13956548C4BB199139A2744C39350272)

32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：

各个段说明如下：

3G用户空间和1G内核空间

静态区域：

text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

data segment(数据段)：存储程序中已初始化的全局变量和静态变量

bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0

动态区域：

heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。

memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时申请大于128KB内存时调用mmap函数）

stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。

### 操作系统中的程序的内存结构

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153)

一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。

BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。

数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配

代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量

text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。

bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。

data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。

数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。

可执行程序在运行时又多出两个区域：栈区和堆区。

栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。

堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。

## A* a = new A; a->i = 10;在内核中的内存分配上发生了什么？

1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。

2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。

3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。

4）a->i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a->i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。