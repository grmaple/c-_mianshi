

## TCP

### TCP的状态变迁图

![image-20200908135523590](https://i.loli.net/2020/10/26/nZT9lKOgW5FADQd.png)

![image-20200908135514317](https://i.loli.net/2020/10/26/8BvHCAW6a2DfTFS.png)

### TCP三次握手

![img](https://pic2.zhimg.com/80/v2-f035fe86a8627d1b7bde4d38574db025_1440w.jpg)

首先客户端发送SYN连接请求报文，服务端接受后回复ACK报文（同时这也是个SYN请求报文），并为这次连接分配资源。客户端接收到ACK报文后也向服务端发送ACK报文段，并分配资源，这样TCP连接就建立了。

- 第一次握手：一开始两端都处于CLOSED关闭状态，客户端将标志位SYN置1，随机产生一个值seq=x，并将该数据包发送给服务端，客户端进入SYN-SENT状态，等待服务端确认。
- 第二次握手：服务端收到数据包后，提供标志位SYN=1得知客户端在请求建立连接，服务端将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给客户端以确认SYN连接请求。服务端进入SYN-RCVD状态，此时操作系统应该要为该TCP连接分配TCP缓存和变量。
- 第三次握手：客户端收到服务端的确认后，检查ack是否为x=1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给服务端以确认SYN连接请求。此时操作系统应该要为该TCP连接分配TCP缓存和变量。服务端检查ack是否为y+1，ACK是否为1，如果正确则连接成功。客户端和服务端都进入ESTABLISHED状态，完成三次握手，随后客户端和服务端都可以传输数据。

### TCP四次挥手

![img](https://pic1.zhimg.com/80/v2-04f7c396a11b2e4902bc21fe9d1a77e4_1440w.jpg)

注意中断连接端可以是客户端，也可以是服务端。

- A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。
- B收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。
- A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。
- B没有要向A发出的数据，B发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。
- A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。

注意在TIME_WAIT状态中，如果TCP 发起主动关闭的一端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后，连接正式关闭，并且所有的资源(包括端口号)都被释放。

### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

其实握手和挥手都是四次，一端发送SYN/FIN报文，另一端发送ACK报文，如此只是完成了一半的工作。因为连接是全双工的，所以这个过程应该进行两次。所以一共发送四次报文。那么为什么连接时是三次握手呢？因为握手时，服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。而挥手时，因为要考虑到半关闭状态(一端关闭连接，另一端如果仍然有数据要发送，所以不关闭连接)，所以不能同时发送FIN和ACK。这里我没说一定是服务端，因为主动发起关闭连接的不止是客户端，服务端也是可以的。首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这个FIN）执行被动关闭。通常一方完成主动关闭而另一方完成被动关闭。

### 为什么执行主动关闭的一端在TIME-WAIT状态必须等待2MSL的时间？

TIME_WAIT状态也称为2MSL等待状态。每个具体 TCP实现必须选择一个报文段最大生存时间MSL。它是任何报文段被丢弃前在网络内的最长时间。

当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在 TIME_WAIT状态停留的时间为2倍的MSL。

两个理由：

- 保证A发送的最后一个ACK报文段能够到达B。
  - 因为最后一个ACK报文段可能会丢失，使得LAST-ACK状态的B收不到对FIN+ACK报文的确定，这时B会超时重传该报文段。如果没有2MSL等待时间，那么A就收不到这个报文，A就会在发送完ACK报文后立即释放连接，而B无法正常进入CLOSED状态（仍然处于LAST-ACK状态，等待A的ACK报文）。
  - 如果有这个2MSL等待时间，那么A就能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态。
- 防止“已失效的连接请求报文段”出现在本连接中。
  - 这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在 2MSL结束后才能再被使用。
  - 在连接处于2MSL等待时，任何迟到的报文段将被丢弃。因为处于2MSL等待的、由该插口对定义的连接在这段时间内不能被再用。
  - A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

### 6个标识位：

- URG 紧急指针，告诉接收TCP模块紧要指针域指着紧要数据。
- ACK 置1时表示确认号（为合法，为0的时候表示数据段不包含确认信息，确认号被忽略。
- PSH 置1时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送。
- RST 置1时重建连接。如果接收到RST位时候，通常发生了某些错误。
- SYN 置1时用来发起一个连接。
- FIN 置1时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了。

### Server端易受到SYN攻击？

服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

**防范SYN攻击措施**：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。

### time_wait状态如何产生，产生原因，如何避免

**1. time_wait状态如何产生？**
由上面的变迁图，首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL指的是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。

**2.time_wait状态产生的原因**

**1）为实现TCP全双工连接的可靠释放**

由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。

**2）为使旧的数据包在网络因过期而消失**

为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remote peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。

**3.time_wait状态如何避免**

首先服务器可以设置SO_REUSEADDR套接字选项（端口复用）来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。